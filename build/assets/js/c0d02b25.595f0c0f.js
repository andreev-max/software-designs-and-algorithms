"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[4706],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=d(n),u=i,c=h["".concat(s,".").concat(u)]||h[u]||m[u]||r;return n?a.createElement(c,o(o({ref:t},p),{},{components:n})):a.createElement(c,o({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9528:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(7294);function i(e){var t=e.src,n=e.title;return a.createElement("iframe",{title:n,src:t,style:{width:"100%",height:"500px",border:0,borderRadius:"4px",overflow:"hidden"},allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"})}},4610:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return d},default:function(){return c},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return h}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=n(9528),l=["components"],s={sidebar_position:3},d="2. Binary Search Tree",p={unversionedId:"algorithms-and-data-structures-part-1/binary_search_tree",id:"algorithms-and-data-structures-part-1/binary_search_tree",title:"2. Binary Search Tree",description:"This data structure is a bit more interesting. With this data structure it's easy to implement a set data type, which is a collection of unique elements. It's also easy to implement operations such as search, finding min or max element in the set and search of previous and next values. All those operations take O(logn) time if the tree is balanced.",source:"@site/docs/7-algorithms-and-data-structures-part-1/binary_search_tree.mdx",sourceDirName:"7-algorithms-and-data-structures-part-1",slug:"/algorithms-and-data-structures-part-1/binary_search_tree",permalink:"/docs/algorithms-and-data-structures-part-1/binary_search_tree",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"1. Elementary Data Structures",permalink:"/docs/algorithms-and-data-structures-part-1/elementary_data_structures"},next:{title:"3. Red-Black Tree",permalink:"/docs/algorithms-and-data-structures-part-1/red-black_tree"}},m={},h=[{value:"2.1 Tree Walks",id:"21-tree-walks",level:2},{value:"2.2 Searching",id:"22-searching",level:2},{value:"2.3 Insert",id:"23-insert",level:2},{value:"2.4 Deletion",id:"24-deletion",level:2}],u={toc:h};function c(e){var t=e.components,s=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"2-binary-search-tree"},"2. Binary Search Tree"),(0,r.kt)("p",null,"This data structure is a bit more interesting. With this data structure it's easy to implement a set data type, which is a collection of unique elements. It's also easy to implement operations such as ",(0,r.kt)("strong",{parentName:"p"},"search"),", finding ",(0,r.kt)("strong",{parentName:"p"},"min")," or ",(0,r.kt)("strong",{parentName:"p"},"max")," element in the set and search of ",(0,r.kt)("strong",{parentName:"p"},"previous")," and ",(0,r.kt)("strong",{parentName:"p"},"next")," values. All those operations take ",(0,r.kt)("inlineCode",{parentName:"p"},"O(logn)")," time if the tree is balanced."),(0,r.kt)("p",null,"Figure 2.1"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tress",src:n(2887).Z,width:"848",height:"420"})),(0,r.kt)("p",null,"On the Figure 2.1 you can see a balanced tree on the left and an unbalanced tree on the right. If the tree is balanced, the operations mentioned above will take ",(0,r.kt)("inlineCode",{parentName:"p"},"\xd8(lgn)")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"\xd8")," - theta. If the tree is unbalanced, the operations will take ",(0,r.kt)("inlineCode",{parentName:"p"},"O(lgn)"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Binary Search Tree")," (BST) is a node-based binary tree data structure which has the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The left subtree of a node contains only nodes with values smaller than the node's value."),(0,r.kt)("li",{parentName:"ul"},"The right subtree of a node contains only nodes with values bigger than the node's value."),(0,r.kt)("li",{parentName:"ul"},"The left and right subtree each must also be a binary search tree or be ",(0,r.kt)("inlineCode",{parentName:"li"},"null"),".")),(0,r.kt)("p",null,"If a node is to be inserted into a tree, it is compared with current node (starting from the root). If the node's value is less than current, we send it down to left subtree. If node's value is greater than or equal to current - it is sent to the right subtree. This process is repeated for each encountered node."),(0,r.kt)("h2",{id:"21-tree-walks"},"2.1 Tree Walks"),(0,r.kt)("p",null,"The binary search tree property allows us to print out all the values in a binary search tree in sorted order by a simple recursive algorithm, called an ",(0,r.kt)("strong",{parentName:"p"},"inorder tree walk"),". This algorithm is named so because it prints the value of the root of a subtree between printing the values in its left subtree and printing those in its right subtree. (Similarly, a ",(0,r.kt)("strong",{parentName:"p"},"preorder tree walk")," prints the root before the values in either subtree, and a ",(0,r.kt)("strong",{parentName:"p"},"postorder tree walk")," prints the root after the values in its subtrees.)"),(0,r.kt)("p",null,"Listing 2.1 - Binary Tree Traversal"),(0,r.kt)(o.Z,{title:"Binary Tree Traversal",src:"https://codesandbox.io/embed/binary-tree-traversal-zhenx4?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark",mdxType:"CodeEmbedLink"}),(0,r.kt)("p",null,"Figure 2.2"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tree",src:n(8747).Z,width:"1094",height:"580"})),(0,r.kt)("p",null,"For example, with a tree in Figure 2.2, those tree walks would give following results:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Inorder (Left, Root, Right): ",(0,r.kt)("inlineCode",{parentName:"li"},"3")," ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," ",(0,r.kt)("inlineCode",{parentName:"li"},"6")," ",(0,r.kt)("inlineCode",{parentName:"li"},"9")," ",(0,r.kt)("inlineCode",{parentName:"li"},"11")," ",(0,r.kt)("inlineCode",{parentName:"li"},"12")),(0,r.kt)("li",{parentName:"ul"},"Preorder (Root, Left, Right): ",(0,r.kt)("inlineCode",{parentName:"li"},"9")," ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," ",(0,r.kt)("inlineCode",{parentName:"li"},"3")," ",(0,r.kt)("inlineCode",{parentName:"li"},"6")," ",(0,r.kt)("inlineCode",{parentName:"li"},"12")," ",(0,r.kt)("inlineCode",{parentName:"li"},"11")),(0,r.kt)("li",{parentName:"ul"},"Postorder (Left, Right, Root): ",(0,r.kt)("inlineCode",{parentName:"li"},"3")," ",(0,r.kt)("inlineCode",{parentName:"li"},"6")," ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," ",(0,r.kt)("inlineCode",{parentName:"li"},"11")," ",(0,r.kt)("inlineCode",{parentName:"li"},"12")," ",(0,r.kt)("inlineCode",{parentName:"li"},"9"))),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The recursive approach is used to implement the Binary Tree Traversal. Check out ",(0,r.kt)("a",{parentName:"p",href:"https://www.collegenote.net/curriculum/data-structures-and-algorithms/41/454/"},"here")," the advantages and disadvantages of using recursion. Feel free to figure out on your own how to implement the same using iterative approach."))),(0,r.kt)("h2",{id:"22-searching"},"2.2 Searching"),(0,r.kt)("p",null,"Because of the BST properties, it's very easy to search for an element with a following function:"),(0,r.kt)("p",null,"Listing 2.2 - searchTree"),(0,r.kt)(o.Z,{title:"Binary Tree - searchTree",src:"https://codesandbox.io/embed/binary-tree-searchtree-mq2g4g?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark",mdxType:"CodeEmbedLink"}),(0,r.kt)("p",null,"We can always find an element in a binary search tree whose value is a minimum by following left child pointers from the root until we encounter a ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),". The search of a tree's maximum is a symmetric procedure:"),(0,r.kt)("p",null,"Listing 2.3 - treeMinimum and treeMaximum"),(0,r.kt)(o.Z,{title:"Binary Tree - treeMinimum and treeMaximum",src:"https://codesandbox.io/embed/binary-tree-treeminimum-and-treemaximum-s0bg2g?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark",mdxType:"CodeEmbedLink"}),(0,r.kt)("p",null,"Given a node in a binary search tree, sometimes we need to find its successor in the sorted order determined by an inorder tree walk. If all values are distinct, the successor of a node ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," is the node with the smallest value greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"node.value"),". The strategy has three basic cases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"in case ",(0,r.kt)("inlineCode",{parentName:"li"},"tree")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," are the same the ",(0,r.kt)("inlineCode",{parentName:"li"},"null")," should be returned"),(0,r.kt)("li",{parentName:"ul"},"in that case ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," has a right subtree we need to find the left most node in its right subtree which is also the lowest node in its right subtree"),(0,r.kt)("li",{parentName:"ul"},"in that case ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," does not have a right subtree we need to walk down the ",(0,r.kt)("inlineCode",{parentName:"li"},"tree")," node until we match the ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," and return its parent")),(0,r.kt)("p",null,"Listing 2.4 - getSuccessor"),(0,r.kt)(o.Z,{title:"Binary Tree - getSuccessor",src:"https://codesandbox.io/embed/binary-tree-getsuccessor-qmk6le?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark",mdxType:"CodeEmbedLink"}),(0,r.kt)("p",null,"For an example for Figure 2.2 the inorder successor of ",(0,r.kt)("inlineCode",{parentName:"p"},"6")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"9"),", the inorder successor of ",(0,r.kt)("inlineCode",{parentName:"p"},"5")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"6")," and inorder successor of ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),"."),(0,r.kt)("h2",{id:"23-insert"},"2.3 Insert"),(0,r.kt)("p",null,"To insert a new value ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," into a binary search tree ",(0,r.kt)("inlineCode",{parentName:"p"},"tree"),", we use the function ",(0,r.kt)("inlineCode",{parentName:"p"},"insertNode"),". It takes a node ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," for which: ",(0,r.kt)("inlineCode",{parentName:"p"},"node.value = value"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"node.left = null"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"node.right = null")," and inserts it into an appropriate position in the tree."),(0,r.kt)("p",null,"Listing 2.5 - insertNode"),(0,r.kt)(o.Z,{title:"Binary Tree - insertNode",src:"https://codesandbox.io/embed/binary-tree-insertnode-rl1ytj?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark",mdxType:"CodeEmbedLink"}),(0,r.kt)("p",null,"In the Figure 2.2, we want to insert ",(0,r.kt)("inlineCode",{parentName:"p"},"7"),". We look at ",(0,r.kt)("inlineCode",{parentName:"p"},"9")," and go left, we look at ",(0,r.kt)("inlineCode",{parentName:"p"},"5")," and go right for ",(0,r.kt)("inlineCode",{parentName:"p"},"6")," and insert ",(0,r.kt)("inlineCode",{parentName:"p"},"7")," into its right subtree."),(0,r.kt)("h2",{id:"24-deletion"},"2.4 Deletion"),(0,r.kt)("p",null,"The overall strategy for deleting a node ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," from a binary search tree ",(0,r.kt)("inlineCode",{parentName:"p"},"tree")," has three basic cases but, as we shall see, one of the cases is a bit tricky:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," is leaf (has no children), then we simply remove it by modifying its parent to replace ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"null")," as its child."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," has just one child, then we elevate that child to take ",(0,r.kt)("inlineCode",{parentName:"li"},"node"),"s position in the tree by modifying ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," parent to replace ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," by ",(0,r.kt)("inlineCode",{parentName:"li"},"node"),"s child."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," has two children, then we find ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," successor ",(0,r.kt)("inlineCode",{parentName:"li"},"parent")," \u2014 which must be in ",(0,r.kt)("inlineCode",{parentName:"li"},"node")," right subtree \u2014 and have ",(0,r.kt)("inlineCode",{parentName:"li"},"parent")," take ",(0,r.kt)("inlineCode",{parentName:"li"},"node"),"s position in the tree. The rest of ",(0,r.kt)("inlineCode",{parentName:"li"},"node"),"s original right subtree becomes ",(0,r.kt)("inlineCode",{parentName:"li"},"parent"),"s new right subtree, and ",(0,r.kt)("inlineCode",{parentName:"li"},"node"),"s left subtree becomes ",(0,r.kt)("inlineCode",{parentName:"li"},"parent"),"s new left subtree. This case is the tricky one because, as we shall see, it matters whether ",(0,r.kt)("inlineCode",{parentName:"li"},"parent")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"node"),"s right child.")),(0,r.kt)("p",null,"Figure 2.3"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tree deletion",src:n(770).Z,width:"936",height:"360"})),(0,r.kt)("p",null,"In the Figure 2.3, we are removing element ",(0,r.kt)("inlineCode",{parentName:"p"},"18"),". Since it has no children, we set the ",(0,r.kt)("inlineCode",{parentName:"p"},"20"),"'s left subtree to ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"Figure 2.4"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tree deletion",src:n(4903).Z,width:"936",height:"484"})),(0,r.kt)("p",null,"In the second case we are removing element ",(0,r.kt)("inlineCode",{parentName:"p"},"25"),". Since it has only one child - ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),"0, we replace the ",(0,r.kt)("inlineCode",{parentName:"p"},"20"),"'s right subtree with ",(0,r.kt)("inlineCode",{parentName:"p"},"30"),"."),(0,r.kt)("p",null,"Figure 2.5"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tree deletion",src:n(9382).Z,width:"934",height:"562"})),(0,r.kt)("p",null,"In the third case, we are removing element ",(0,r.kt)("inlineCode",{parentName:"p"},"20"),". Node ",(0,r.kt)("inlineCode",{parentName:"p"},"20")," has 2 children. To delete the node we need to find its inorder successor or inorder predecessor. In our example the inorder successor is node ",(0,r.kt)("inlineCode",{parentName:"p"},"30")," and inorder predecessor is node ",(0,r.kt)("inlineCode",{parentName:"p"},"19"),". The inorder successor will be the minimum of the right subtree. The inorder predecessor is going to be the maximum of the left subtree. After replacing the node with found value, we must delete the replacing node."),(0,r.kt)("p",null,"Listing 2.6 - deleteNode"),(0,r.kt)(o.Z,{title:"Binary Tree - deleteNode",src:"https://codesandbox.io/embed/binary-tree-deletenode-cstjdj?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark",mdxType:"CodeEmbedLink"}),(0,r.kt)("p",null,"The worst-case time complexity of search, insert, and delete operations is ",(0,r.kt)("inlineCode",{parentName:"p"},"O(h)")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"h")," is the height of the Binary Search Tree. In the worst case, we may have to travel from root to the deepest leaf node. The height of a skewed tree may become ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," (number of nodes), and the time complexity of search and insert operation may become ",(0,r.kt)("inlineCode",{parentName:"p"},"O(n)"),"."))}c.isMDXComponent=!0},770:function(e,t,n){t.Z=n.p+"assets/images/node_deletion_from_tree1-2e27fe4031a752fc6d36b98ac97e4b5f.jpg"},4903:function(e,t,n){t.Z=n.p+"assets/images/node_deletion_from_tree2-2baa7507d15837ceba1f8655a1ba38a3.jpg"},9382:function(e,t,n){t.Z=n.p+"assets/images/node_deletion_from_tree3-dfb824761b363bd86b370ca3f5c4e146.jpg"},8747:function(e,t,n){t.Z=n.p+"assets/images/tree1-d9f63ee003703877df0648573d08e5bc.jpg"},2887:function(e,t,n){t.Z=n.p+"assets/images/trees-b99c6d01eac007a1dcfd7877d9a6185e.jpg"}}]);