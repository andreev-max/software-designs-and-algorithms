"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[1908],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=c(n),p=o,u=d["".concat(l,".").concat(p)]||d[p]||m[p]||s;return n?a.createElement(u,i(i({ref:t},h),{},{components:n})):a.createElement(u,i({ref:t},h))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,i=new Array(s);i[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var c=2;c<s;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1554:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return m}});var a=n(7462),o=n(3366),s=(n(7294),n(3905)),i=["components"],r={sidebar_position:5},l="4. Behavioral Design Patterns",c={unversionedId:"design-patterns/behavioral_design_patterns",id:"design-patterns/behavioral_design_patterns",title:"4. Behavioral Design Patterns",description:"Behavioral design patterns are related to algorithms and the assignment of responsibilities between objects. They can be based on both \u2013 inheritance and composition.",source:"@site/docs/5-design-patterns/behavioral_design_patterns.md",sourceDirName:"5-design-patterns",slug:"/design-patterns/behavioral_design_patterns",permalink:"/docs/design-patterns/behavioral_design_patterns",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"3. Structural Design Patterns",permalink:"/docs/design-patterns/structural_design_patterns"},next:{title:"5. Conclusion",permalink:"/docs/design-patterns/conclusion"}},h={},m=[{value:"4.1 Template Method",id:"41-template-method",level:2},{value:"4.1.1 Template Method structure",id:"411-template-method-structure",level:3},{value:"4.1.2 Template Method example",id:"412-template-method-example",level:3},{value:"4.1.3 When to apply, pros and cons",id:"413-when-to-apply-pros-and-cons",level:3},{value:"4.2 Strategy",id:"42-strategy",level:2},{value:"4.2.1 Strategy structure",id:"421-strategy-structure",level:3},{value:"4.2.2 Strategy example",id:"422-strategy-example",level:3},{value:"4.2.3 When to apply, pros and cons",id:"423-when-to-apply-pros-and-cons",level:3},{value:"4.3 Visitor",id:"43-visitor",level:2},{value:"4.3.1 Visitor structure",id:"431-visitor-structure",level:3},{value:"4.3.2 Visitor example",id:"432-visitor-example",level:3},{value:"4.3.3 When to apply, pros and cons",id:"433-when-to-apply-pros-and-cons",level:3},{value:"4.4 Command",id:"44-command",level:2},{value:"4.4.1 Command real-life example",id:"441-command-real-life-example",level:3},{value:"4.4.2 Command structure",id:"442-command-structure",level:3},{value:"4.4.3 Command example",id:"443-command-example",level:3},{value:"4.4.4 When to apply, pros and cons",id:"444-when-to-apply-pros-and-cons",level:3}],d={toc:m};function p(e){var t=e.components,r=(0,o.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"4-behavioral-design-patterns"},"4. Behavioral Design Patterns"),(0,s.kt)("p",null,"Behavioral design patterns are related to algorithms and the assignment of responsibilities between objects. They can be based on both \u2013 inheritance and composition."),(0,s.kt)("h2",{id:"41-template-method"},"4.1 Template Method"),(0,s.kt)("p",null,"Template Method is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but allows subclasses to override specific steps of the algorithm without changing its structure."),(0,s.kt)("h3",{id:"411-template-method-structure"},"4.1.1 Template Method structure"),(0,s.kt)("p",null,"The Template Method pattern suggests you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single ",(0,s.kt)("em",{parentName:"p"},"template method"),". The steps may either be abstract, or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some optional ones if needed (but not the template method itself)."),(0,s.kt)("p",null,"There are three types of steps:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"abstract steps")," must be implemented by every subclass"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"optional steps")," already have default implementation, but can be overridden if needed"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"hooks")," are optional steps with an empty body. A template method would work even if a hook is not overridden. Usually, hooks are placed before and after crucial steps of algorithms, providing subclasses with additional extension points for an algorithm.")),(0,s.kt)("p",null,"Figure 4.1 - Template Method"),(0,s.kt)("img",{width:"700",src:n(662).Z,alt:"Template Method"}),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"AbstractClass")," declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"ConcreteClass"),"es can override all the steps, but not the template method itself.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.1 - Template Method for making tea and coffee"',title:'"Listing',4.1:!0,"-":!0,Template:!0,Method:!0,for:!0,making:!0,tea:!0,and:!0,'coffee"':!0},"boilWater(); \nbrew(); \npourInCup() \naddCondiments();\n")),(0,s.kt)("h3",{id:"412-template-method-example"},"4.1.2 Template Method example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.2"',title:'"Listing','4.2"':!0},"abstract class Builder {\n  // Template method\n  public build() {\n    this.test();\n    this.lint();\n    this.assemble();\n    this.deploy();\n  }\n\n  abstract test();\n  abstract lint();\n  abstract assemble();\n  abstract deploy();\n}\n\nclass AndroidBuilder extends Builder {\n  public test() { return 'Running android tests'; }\n  public lint() { return 'Linting android code'; }\n  public assemble() { return 'Assembling android build'; }\n  public deploy() { return 'Deploying android build to server'; }\n}\n\nclass IosBuilder extends Builder {\n  public test() { return 'Running ios tests'; }\n  public lint() { return 'Linting ios code'; }\n  public assemble() { return 'Assembling ios build'; }\n  public deploy() { return 'Deploying ios build to server'; }\n}\n\nconst androidBuilder = new AndroidBuilder();\n\nandroidBuilder.build();\n// Running android tests\n// Linting android code\n// Assembling android build\n// Deploying android build to server\n\nconst iosBuilder = new IosBuilder();\n\nandroidBuilder.build();\n// Running ios tests\n// Linting ios code\n// Assembling ios build\n// Deploying ios build to server\n")),(0,s.kt)("h3",{id:"413-when-to-apply-pros-and-cons"},"4.1.3 When to apply, pros and cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"to let clients extend only particular steps of an algorithm, but not the whole algorithm or its structure. The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass"),(0,s.kt)("li",{parentName:"ul"},"when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify all classes when the algorithm changes. When you turn such an algorithm into a template method, you can also move the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses")),(0,s.kt)("p",null,"Pros"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"letting clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm"),(0,s.kt)("li",{parentName:"ul"},"move the duplicate code into a superclass")),(0,s.kt)("p",null,"Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"some clients may be limited by the provided skeleton of an algorithm"),(0,s.kt)("li",{parentName:"ul"},"you might violate the Liskov Substitution Principle by suppressing a default step implementation via a subclass"),(0,s.kt)("li",{parentName:"ul"},"template methods tend to be harder to maintain the more steps they have")),(0,s.kt)("h2",{id:"42-strategy"},"4.2 Strategy"),(0,s.kt)("p",null,"Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable. Allows switching between algorithms or strategies depending on situation."),(0,s.kt)("h3",{id:"421-strategy-structure"},"4.2.1 Strategy structure"),(0,s.kt)("p",null,"The Strategy pattern suggests you take a class that does something specific in a lot of diverse ways and extract all these algorithms into separate classes called ",(0,s.kt)("em",{parentName:"p"},"strategies"),". The original class, called ",(0,s.kt)("em",{parentName:"p"},"context"),", must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own."),(0,s.kt)("p",null,"The context is not responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. In fact, the context does not know much about strategies. It works with all strategies through the same generic interface, which only exposes a single method for triggering the algorithm encapsulated within the selected strategy. This way the context becomes independent of concrete strategies, so you can add new algorithms or modify existing ones without changing the code of the context or other strategies."),(0,s.kt)("p",null,"Figure 4.2 - Strategy"),(0,s.kt)("img",{width:"700",src:n(5215).Z,alt:"Strategy"}),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Context")," keeps a reference to one of the concrete strategies and communicates with this object only via the strategy interface."),(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Strategy")," interface is unified for all concrete strategies. It declares a method the context uses to execute a strategy."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"ConcreteStrategies")," implement different variations of an algorithm the context uses."),(0,s.kt)("li",{parentName:"ol"},"The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context does not know what type of strategy it works with or how the algorithm is executed."),(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Client")," creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.")),(0,s.kt)("h3",{id:"422-strategy-example"},"4.2.2 Strategy example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.3"',title:'"Listing','4.3"':!0},"// The strategy interface declares operations common\n// to all supported versions of some algorithm.\ninterface Strategy {\n  execute(a: number, b: number): number;\n}\n\n// Concrete strategies implement the algorithm while following\n// the base strategy interface. The interface makes them\n// interchangable in the context.\nclass ConcreteStrategyAdd implements Strategy {\n  execute(a, b) {\n    return a + b;\n  }\n}\n\nclass ConcreteStrategySubstract implements Strategy {\n  execute(a, b) {\n    return a - b;\n  }\n}\n\nclass ConcreteStrategyMultiply implements Strategy {\n  execute(a, b) {\n    return a * b;\n  }\n}\n")),(0,s.kt)("p",null,"We have common interface and 3 concrete classes implementing this interface. The ",(0,s.kt)("inlineCode",{parentName:"p"},"Context")," in not aware of what specific strategy he works with. ",(0,s.kt)("inlineCode",{parentName:"p"},"Context")," knows that it can send the execution message. Thus, the client decides when and which strategy should be used. It can switch them on the fly, getting different behavior, without changing the interface."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.4"',title:'"Listing','4.4"':!0},"// The context defines the interface of interest to clients.\nclass Context {\n  private strategy: Strategy;\n\n  setStrategy(s: Strategy) {\n    this.strategy = s;\n  }\n    // The context delegates some work to the strategy object\n    // instead of implementing multiple versions of the\n    // algorithm on its own.\n  executeStrategy(a: number, b: number) {\n    return this.strategy.execute(a, b);\n  }\n}\n\nlet ctx = new Context();\n\nctx.setStrategy(new ConcreteStrategyAdd());\nctx.executeStrategy(5, 2); // 7\n")),(0,s.kt)("h3",{id:"423-when-to-apply-pros-and-cons"},"4.2.3 When to apply, pros and cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime. The Strategy pattern lets you indirectly alter the object's behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in diverse ways"),(0,s.kt)("li",{parentName:"ul"},"when you have a lot of similar classes that only differ in the way they execute some behavior. The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code"),(0,s.kt)("li",{parentName:"ul"},"to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic. The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime"),(0,s.kt)("li",{parentName:"ul"},"when your class has a massive conditional operator that switches between different variants of the same algorithm")),(0,s.kt)("p",null,"Pros"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"swapping algorithms used inside an object at runtime"),(0,s.kt)("li",{parentName:"ul"},"isolating the implementation details of an algorithm from the code that uses it"),(0,s.kt)("li",{parentName:"ul"},"replacing inheritance with composition"),(0,s.kt)("li",{parentName:"ul"},"introducing new strategies without having to change the context")),(0,s.kt)("p",null,"Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"if you have only a couple of algorithms, and they rarely change, there is no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern"),(0,s.kt)("li",{parentName:"ul"},"clients must be aware of the differences between strategies to be able to select a proper one")),(0,s.kt)("h2",{id:"43-visitor"},"4.3 Visitor"),(0,s.kt)("p",null,"Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate."),(0,s.kt)("h3",{id:"431-visitor-structure"},"4.3.1 Visitor structure"),(0,s.kt)("p",null,"Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas, etc. The nodes are connected with others if there is a relation between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object."),(0,s.kt)("p",null,"At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you were not coupling the code which called the export method to concrete classes of nodes. The Visitor pattern suggests you put the new behavior into a separate class called visitor, instead of trying to integrate it into existing classes. The original object that has to perform the behavior is now passed to one of the visitor's methods as an argument, providing the method access to all necessary data contained within the object."),(0,s.kt)("p",null,"Now, what if that behavior can be executed over objects of different classes? For example, in our case with XML export, the actual implementation will probably be a little different across various node classes. Thus, the visitor class may define not one, but a set of methods, each of which could take arguments of different types."),(0,s.kt)("p",null,"Figure 4.3 - Visitor"),(0,s.kt)("img",{width:"700",src:n(5396).Z,alt:"Visitor"}),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Visitor")," interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different."),(0,s.kt)("li",{parentName:"ol"},"Each ",(0,s.kt)("inlineCode",{parentName:"li"},"ConcreteVisitor")," implements several versions of the same behaviors, tailored for different concrete element classes."),(0,s.kt)("li",{parentName:"ol"},'The Element interface declares a method for "accepting" visitors. This method should have one parameter declared with the type of the visitor interface.'),(0,s.kt)("li",{parentName:"ol"},"Each ",(0,s.kt)("inlineCode",{parentName:"li"},"ConcreteElement")," must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor's method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object."),(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Client")," usually represents a collection or some other complex object (for example, a Composite tree). Usually, clients are not aware of all the concrete element classes because they work with objects from that collection via some abstract interface.")),(0,s.kt)("h3",{id:"432-visitor-example"},"4.3.2 Visitor example"),(0,s.kt)("p",null,"The element interface declares an ",(0,s.kt)("inlineCode",{parentName:"p"},"accept")," method that takes the base visitor interface as an argument. Each concrete element class must implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"accept")," method in such a way that it calls the visitor's method that corresponds to the element's class."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.5"',title:'"Listing','4.5"':!0},"// The component interface declares an 'accept' method that\n// takes the base visitor interface as an argument.\ninterface Shape {\n  move(x, y);\n  draw();\n  accept(v: Visitor);\n}\n\n// Each concrete component class must implement the 'accept' method\nclass Dot implements Shape {\n  accept(v: Visitor) { v.visitDot(this); }\n  move(x, y) {}\n  draw() {}\n}\n\nclass Circle implements Shape {\n  accept(v: Visitor) { v.visitCircle(this); }\n  move(x, y) {}\n  draw() {}\n}\n\nclass Rectangle implements Shape {\n  accept(v: Visitor) { v.visitRectangle(this); }\n  move(x, y) {}\n  draw() {}\n}\n")),(0,s.kt)("p",null,"The Visitor interface declares a set of visiting methods that correspond to element classes. The signature of a visiting method lets the visitor identify the exact class of the element that it's dealing with."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 4.6"',title:'"Listing','4.6"':!0},"// The Visitor interface declares a set of visiting methods that\n// correspond to component classes.\ninterface Visitor {\n  visitDot(d: Dot);\n  visitCircle(c: Circle);\n  visitRectangle(r: Rectangle);\n}\n\nclass JSONExportVisitor implements Visitor {\n  visitDot(d: Dot) {\n    // Export the dot's ID and coordinates.\n  }\n\n  visitCircle(d: Circle) {\n    // Export the circle's ID, center coordinates and radius.\n  }\n\n  visitRectangle(d: Rectangle) {\n    // Export the rectangle's ID, left-top coordinates, width and height.\n  }\n}\n\n// The client code can run visitor operations over any set of\n// elements without figuring out their concrete classes. The\n// 'accept' operation directs a call to the appropriate operation\n// in the visitor object.\nconst allShapes = [new Dot(), new Circle(), new Rectangle()];\nconst exportVisitor = new JSONExportVisitor();\n\nallShapes.forEach(shape => shape.accept(exportVisitor));\n")),(0,s.kt)("p",null,"Concrete visitors implement several versions of the same algorithm, which can work with all concrete element classes."),(0,s.kt)("h3",{id:"433-when-to-apply-pros-and-cons"},"4.3.3 When to apply, pros and cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"when you need to perform an operation on all elements of a complex object structure (for example, an object tree). The Visitor pattern allows you to execute an operation over a set of objects with different classes by having a visitor object implementing several variants of the same operation, which correspond to all target classes"),(0,s.kt)("li",{parentName:"ul"},"to clean up the business logic of auxiliary behaviors. The pattern allows you to make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes"),(0,s.kt)("li",{parentName:"ul"},"when a behavior makes sense only in some classes of a class hierarchy, but not in others. You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty")),(0,s.kt)("p",null,"Pros"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"introducing new behavior that can work with objects of different classes without changing these classes (Open/Closed)"),(0,s.kt)("li",{parentName:"ul"},"moving multiple versions of the same behavior into the same class (Single Responsibility)"),(0,s.kt)("li",{parentName:"ul"},"a visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure")),(0,s.kt)("p",null,"Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"you need to update all visitors each time a class gets added to or removed from the element hierarchy"),(0,s.kt)("li",{parentName:"ul"},"visitors might lack the necessary access to the private fields and methods of the elements that they are supposed to work with")),(0,s.kt)("h2",{id:"44-command"},"4.4 Command"),(0,s.kt)("p",null,"Command is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation allows you to parameterize methods with different requests, delay or queue a request's execution, and support undoable operations. In other words \u2013 it allows to incapsulate actions in objects. The main idea of Command pattern is to provide a way of separating client from receiver."),(0,s.kt)("h3",{id:"441-command-real-life-example"},"4.4.1 Command real-life example"),(0,s.kt)("p",null,"Remote control example \u2013 we've got on and off buttons, client configures each of these buttons for particular commands. At the same time buttons are not aware of which command are they assigned to. Another example is a friendly waiter taking your order, writing it down on a piece of paper. Then he goes to the kitchen and sticks the order on the wall. After a while, the order gets to the chef, who reads it and cooks the meal accordingly. The cook places the meal on a tray along with the order. The waiter discovers the tray, checks the order to make sure everything is as you wanted it, and brings everything to your table."),(0,s.kt)("h3",{id:"442-command-structure"},"4.4.2 Command structure"),(0,s.kt)("p",null,"Good software design is often based on the ",(0,s.kt)("em",{parentName:"p"},"principle of separation of concerns"),", which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic. In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a ",(0,s.kt)("em",{parentName:"p"},"request"),"."),(0,s.kt)("p",null,"The Command pattern suggests that GUI objects should not send these requests directly. Instead, you should extract all the request details, such as the object being called, the name of the method and the list of arguments into a separate command class with a single method that triggers this request."),(0,s.kt)("p",null,"Command objects serve as links between various GUI and business logic objects. From now on, the GUI object does not need to know what business logic object will receive the request and how it will be processed. The GUI object just triggers the ",(0,s.kt)("em",{parentName:"p"},"command"),", which handles all the details."),(0,s.kt)("p",null,"The next step is make your commands to implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender's behavior at runtime."),(0,s.kt)("p",null,"Figure 4.4 - Command"),(0,s.kt)("img",{width:"700",src:n(533).Z,alt:"Command"}),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Sender")," class (aka invoker) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender is not responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor."),(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Command")," interface usually declares just a single method for executing the command."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"ConcreteCommand"),"s implement various kinds of requests. A concrete command is not supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, to simplify the code, these classes can be merged."),(0,s.kt)("li",{parentName:"ol"},"Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor"),(0,s.kt)("li",{parentName:"ol"},"The ",(0,s.kt)("inlineCode",{parentName:"li"},"Receiver")," class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work."),(0,s.kt)("li",{parentName:"ol"},"The Client creates and configures concrete command objects. The client must pass all the request parameters, including a receiver instance, into the command's constructor. After that, the resulting command may be associated with one or multiple senders.")),(0,s.kt)("h3",{id:"443-command-example"},"4.4.3 Command example"),(0,s.kt)("p",null,"In this example the Command pattern handles command execution history, allows to cancel them if necessary. Commands, altering the editor state (e.g. paste command), save a copy of editor state before execution."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"abstract class Command {\n  protected app: Application;\n  protected editor: Editor;\n  protected backup: string;\n\n  constructor (app: Application, editor: Editor) {\n      this.app = app;\n      this.editor = editor;\n  }\n\n  saveBackup() {\n    this.backup = this.editor.text;\n  }\n\n  undo() {\n    this.editor.text = this.backup;\n  }\n\n  abstract execute();\n}\n")),(0,s.kt)("p",null,"Copies of executed commands are placed into command history, where they can be accessed for cancelling.  Classes of UI, command history and others don't depend on concrete commands, since they work via common interface with them. Thus, new commands can be added to application without changing existing code."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class CopyCommand extends Command {\n  execute() {\n    this.app.clipboard = this.editor.getSelection();\n  }\n}\nclass PasteCommand extends Command {\n  execute() {\n    this.saveBackup();\n    this.editor.replaceSelection(this.app.clipboard);\n  }\n}\nclass CommandHistory {\n  private history: Command[];\n\n  push(c: Command) { this.history.push(c); }\n  pop(): Command { return this.history[this.history.length -1]; }\n}\nclass Editor {\n  text: string;\n\n  getSelection() { return 'some selection'; }\n  replaceSelection(clipboard) { return `some ${clipboard} selection`; }\n}\n")),(0,s.kt)("p",null,"The application class sets up object relations. It acts as a sender: when something needs to be done, it creates a command object and executes it."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"class Application {\n  clipboard: string;\n  editor: Editor;\n  activeEditor: Editor;\n  history: CommandHistory;\n\n  bindComands() {\n    shortcuts.onkeypress('Ctrl+C', () => {\n      return this.executeCommand(new CopyCommand(this, this.editor));\n    });\n    shortcuts.onkeypress('Ctrl+V', () => {\n      return this.executeCommand(new PasteCommand(this, this.editor));\n    });\n  }\n\n  executeCommand(command: Command) {\n    this.history.push(command);\n    command.execute();\n  }\n\n  undo() {\n    const command = this.history.pop();\n    command.undo();\n  }\n}\n")),(0,s.kt)("p",null,"Take the most recent command from the history and run its undo method. Note that we don't know the class of that command. But we don't have to, since the command knows how to undo its own action."),(0,s.kt)("h3",{id:"444-when-to-apply-pros-and-cons"},"4.4.4 When to apply, pros and cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"when you want to parametrize objects with operations. The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc. Here's an example: you're developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item"),(0,s.kt)("li",{parentName:"ul"},"when you want to queue operations, schedule their execution, or execute them remotely. As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there's even more! In the same way, you can queue, log or send commands over the network"),(0,s.kt)("li",{parentName:"ul"},"when you want to implement reversible operations. Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all. To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application's state. This method has two drawbacks. First, it isn't that easy to save an application's state because some of it can be private. This problem can be mitigated with the Memento pattern. Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.")),(0,s.kt)("p",null,"Pros"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"decoupling classes that invoke operations from classes that perform these operations (Single Responsibility)"),(0,s.kt)("li",{parentName:"ul"},"introducing new commands into the app without breaking existing client code (Open/Closed)"),(0,s.kt)("li",{parentName:"ul"},"implementing undo/redo"),(0,s.kt)("li",{parentName:"ul"},"implementing deferred execution of operations"),(0,s.kt)("li",{parentName:"ul"},"assembling a set of simple commands into a complex one")),(0,s.kt)("p",null,"Cons"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the code may become more complicated since you're introducing a whole new layer between senders and receivers")))}p.isMDXComponent=!0},533:function(e,t,n){t.Z=n.p+"assets/images/command-c011688b7000a00229e6bf0c50f59c69.jpg"},5215:function(e,t,n){t.Z=n.p+"assets/images/strategy-876dad5ea8c7b3d60f1e89bbc772a44b.jpg"},662:function(e,t,n){t.Z=n.p+"assets/images/template_method-453711ff10ef3ec2e7b73dc32da7eb92.jpg"},5396:function(e,t,n){t.Z=n.p+"assets/images/visitor-f76bef5623b68b59518dcbb4b3f8e520.jpg"}}]);