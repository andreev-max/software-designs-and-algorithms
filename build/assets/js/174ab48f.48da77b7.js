"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[2630],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,g=c["".concat(s,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(g,o(o({ref:t},m),{},{components:n})):a.createElement(g,o({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},595:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={sidebar_position:1},s="1. Functional programing (FP)",p={unversionedId:"functional-programming/general_fp",id:"functional-programming/general_fp",title:"1. Functional programing (FP)",description:"Functional programming is a programming paradigm, that is another, different than OOP, way of thinking about how to build the application. The main unit of functional programming is a function. We already use functions on daily basis so what is the difference in this case? To use FP we have to think differently, the aim is to abstract control flows and operations on data with functions, so by doing that we could avoid side effects and reduce mutation of state.",source:"@site/docs/4-functional-programming/general_fp.md",sourceDirName:"4-functional-programming",slug:"/functional-programming/general_fp",permalink:"/docs/functional-programming/general_fp",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"6. \ud83d\udcda Home Task",permalink:"/docs/building-blocks-of-oop-part-2/hometask"},next:{title:"2. Functional language possibilities",permalink:"/docs/functional-programming/language_possibilities"}},m={},u=[{value:"1.1 Imperative programing paradigm",id:"11-imperative-programing-paradigm",level:2},{value:"1.2 Declarative programing paradigm",id:"12-declarative-programing-paradigm",level:2},{value:"1.3 Is FP imperative or declarative?",id:"13-is-fp-imperative-or-declarative",level:2}],c={toc:u};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"1-functional-programing-fp"},"1. Functional programing (FP)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Functional programming")," is a ",(0,i.kt)("strong",{parentName:"p"},"programming paradigm"),", that is another, different than OOP, way of thinking about how to build the application. The main unit of functional programming is a function. We already use functions on daily basis so what is the difference in this case? To use FP we have to think differently, the aim is to ",(0,i.kt)("strong",{parentName:"p"},"abstract control flows and operations")," on data with functions, so by doing that we could ",(0,i.kt)("strong",{parentName:"p"},"avoid side effects")," and ",(0,i.kt)("strong",{parentName:"p"},"reduce mutation")," of state."),(0,i.kt)("h2",{id:"11-imperative-programing-paradigm"},"1.1 Imperative programing paradigm"),(0,i.kt)("p",null,"Imperative programming is one of the oldest programming paradigms. It has a close connection to machine architecture. By changing the state through assignment statements we are achieving results. The state is changing by performing step-by-step tasks. The main concept is how to achieve our goal. If you are following the imperative programming paradigm you have several statements and the result is stored after execution of all of them."),(0,i.kt)("p",null,"Pros"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Very simple to implement")),(0,i.kt)("p",null,"Cons"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Less efficient and less productive"),(0,i.kt)("li",{parentName:"ul"},"Parallel programming is not possible")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Listing 1.1"',title:'"Listing','1.1"':!0},"const doubleMap = (numbers) => {\n  const doubled = [];\n\n  for (let i = 0; i < numbers.length; i++) {\n    doubled.push(numbers[i] * 2);\n  }\n\n  return doubled;\n};\n\nconsole.log(doubleMap([2, 3, 4])); // [4, 6, 8]\n")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"Listing 1.1")," our goal is to double each array element and return a new array with doubled values. As was mentioned before, in case of imperative programming, our focus is on ",(0,i.kt)("strong",{parentName:"p"},"HOW")," to achieve the result. So, we have several main steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"creation of new empty array ",(0,i.kt)("inlineCode",{parentName:"li"},"doubled")),(0,i.kt)("li",{parentName:"ul"},"going through ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"for")," loop"),(0,i.kt)("li",{parentName:"ul"},"double each element"),(0,i.kt)("li",{parentName:"ul"},"push the doubled element into ",(0,i.kt)("inlineCode",{parentName:"li"},"doubled")," array"),(0,i.kt)("li",{parentName:"ul"},"return ",(0,i.kt)("inlineCode",{parentName:"li"},"doubled")," array")),(0,i.kt)("p",null,"By doing these steps one-by-one as a result we will have ",(0,i.kt)("inlineCode",{parentName:"p"},"[4, 6, 8]"),"."),(0,i.kt)("h2",{id:"12-declarative-programing-paradigm"},"1.2 Declarative programing paradigm"),(0,i.kt)("p",null,"The main idea of ",(0,i.kt)("strong",{parentName:"p"},"Declarative programming")," paradigm is to define ",(0,i.kt)("strong",{parentName:"p"},"what")," needs to be accomplished by the program, but ",(0,i.kt)("strong",{parentName:"p"},"not how")," it needs to be implemented. So, in other words, instead of instructing how to achieve the desired results we focus only on the result itself. It is different from imperative programming which focuses on a set of commands which need to be executed in order to achieve the required solution. Declarative programming describes a particular class of problems that have to be solved and a language implementation takes care of finding the solution. With this approach, the resulting program is simpler to read. The same example, but in a declarative way."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Listing 1.2"',title:'"Listing','1.2"':!0},"const doubleMap = (numbers) => numbers.map((n) => n * 2);\n\nconsole.log(doubleMap([2, 3, 4])); // [4, 6, 8]\n")),(0,i.kt)("p",null,"Let's analyze what is the difference - in this case, we know that ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," function creates a new array, so we do not need to think about it. We also know that ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," goes through the array, so we can skip the implementation of these parts."),(0,i.kt)("p",null,"So, there are several main steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"all routine work is done by ",(0,i.kt)("inlineCode",{parentName:"li"},"map")),(0,i.kt)("li",{parentName:"ul"},"we only pass the ",(0,i.kt)("inlineCode",{parentName:"li"},"callback")," in which we provide the condition which is important to us in this case.")),(0,i.kt)("h2",{id:"13-is-fp-imperative-or-declarative"},"1.3 Is FP imperative or declarative?"),(0,i.kt)("p",null,"In order to answer this question, let's compare these two approaches:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Characteristic"),(0,i.kt)("th",{parentName:"tr",align:null},"Imperative Approach"),(0,i.kt)("th",{parentName:"tr",align:null},"Functional Approach"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Description"),(0,i.kt)("td",{parentName:"tr",align:null},"The program directly changes computed state"),(0,i.kt)("td",{parentName:"tr",align:null},"The program avoids mutating state and computation data")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Key points"),(0,i.kt)("td",{parentName:"tr",align:null},"Direct assignments, global variables, common data structures"),(0,i.kt)("td",{parentName:"tr",align:null},"Compositiionality, resursion, no side effects")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Programmer focus"),(0,i.kt)("td",{parentName:"tr",align:null},"How to perform tasks and how to track state changing"),(0,i.kt)("td",{parentName:"tr",align:null},"What is desired and what transformations are required")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"State changes"),(0,i.kt)("td",{parentName:"tr",align:null},"Important"),(0,i.kt)("td",{parentName:"tr",align:null},"Non-existent")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Order of execution"),(0,i.kt)("td",{parentName:"tr",align:null},"Important"),(0,i.kt)("td",{parentName:"tr",align:null},"Low importance")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Primary flow control"),(0,i.kt)("td",{parentName:"tr",align:null},"Loops, conditionals and function calls"),(0,i.kt)("td",{parentName:"tr",align:null},"Function calls, resursion")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Primary manipulation unit"),(0,i.kt)("td",{parentName:"tr",align:null},"Instances of structures or classes"),(0,i.kt)("td",{parentName:"tr",align:null},"Functions as first-class objects and data collections")))),(0,i.kt)("p",null,"As we can see FP implements most of the declarative rules, such as programmers focus on what to do, composition, recursion, immutability, functions as first-class objects, etc."))}d.isMDXComponent=!0}}]);