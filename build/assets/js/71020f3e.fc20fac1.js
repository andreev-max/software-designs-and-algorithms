"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[5468],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),u=c(n),p=a,m=u["".concat(l,".").concat(p)]||u[p]||d[p]||s;return n?i.createElement(m,o(o({ref:t},h),{},{components:n})):i.createElement(m,o({ref:t},h))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var c=2;c<s;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},18:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return d}});var i=n(7462),a=n(3366),s=(n(7294),n(3905)),o=["components"],r={sidebar_position:4},l="3. Mixins",c={unversionedId:"building-blocks-of-oop-part-2/mixins",id:"building-blocks-of-oop-part-2/mixins",title:"3. Mixins",description:"3.1 Sharing Role Behavior with Mixins",source:"@site/docs/3-building-blocks-of-oop-part-2/mixins.md",sourceDirName:"3-building-blocks-of-oop-part-2",slug:"/building-blocks-of-oop-part-2/mixins",permalink:"/docs/building-blocks-of-oop-part-2/mixins",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"2. Duck Typing",permalink:"/docs/building-blocks-of-oop-part-2/duck_typing"},next:{title:"4. The Law of Demeter",permalink:"/docs/building-blocks-of-oop-part-2/the_law_of_demeter"}},h={},d=[{value:"3.1 Sharing Role Behavior with Mixins",id:"31-sharing-role-behavior-with-mixins",level:2},{value:"3.2 Understanding Roles",id:"32-understanding-roles",level:2},{value:"3.3 Writing the Concrete Code",id:"33-writing-the-concrete-code",level:2},{value:"3.4 Mixins: Writing Inheritable Code",id:"34-mixins-writing-inheritable-code",level:2}],u={toc:d};function p(e){var t=e.components,r=(0,a.Z)(e,o);return(0,s.kt)("wrapper",(0,i.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"3-mixins"},"3. Mixins"),(0,s.kt)("h2",{id:"31-sharing-role-behavior-with-mixins"},"3.1 Sharing Role Behavior with Mixins"),(0,s.kt)("p",null,"Mixins is another OOD tool, inheritance is not the only way to share a behavior, every problem which we solve using inheritance also can be solved using other tools, and one of such tools are mixins. But each tool has its pros and cons so let us look on what mixins can give us and what the price we must pay to use them."),(0,s.kt)("h2",{id:"32-understanding-roles"},"3.2 Understanding Roles"),(0,s.kt)("p",null,"Sometimes you need to share some behavior between non-related objects, such case is a direct opposite to inheritance hierarchy (",(0,s.kt)("em",{parentName:"p"},"IS-A")," relation). It is rather a role, which object can play on some state of its lifecycle. Let us review some basic example below:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.1"',title:'"Listing','3.1"':!0},"const sayMixin = {\n  say(phrase) {\n    alert(phrase);\n  }\n};\n\nconst sayHiMixin = {\n  __proto__: sayMixin,\n  sayHi() {\n    super.say(`Hello ${this.name}`);\n  },\n  sayBye() {\n    super.say(`Bye ${this.name}`);\n  }\n};\n\nclass User {\n  constructor(public name) {}\n}\n")),(0,s.kt)("p",null,"We have ",(0,s.kt)("inlineCode",{parentName:"p"},"sayMixin")," with say method which prints given phrase on the screen, we also have its extended version \u2013 ",(0,s.kt)("inlineCode",{parentName:"p"},"sayHiMixin"),". When you need to use mixin functionality on some object, you can just add it to the object's prototype, and this will give us the possibility to use mixins methods on this object."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2"',title:'"Listing','3.2"':!0},"Object.assign(\n    User.prototype,\n    sayHiMixin\n);\n\nnew User('Dave').sayHi();\n")),(0,s.kt)("p",null,"But such approach has some consequences, prototypes functionality is not the most convenient in usage, apart from that, ",(0,s.kt)("inlineCode",{parentName:"p"},"Object.assign()")," only makes a shallow copy, so you can use existing JavaScript libraries to make mixins usage easier."),(0,s.kt)("h2",{id:"33-writing-the-concrete-code"},"3.3 Writing the Concrete Code"),(0,s.kt)("p",null,"To better understand how mixins work and what they can give us we will go back to bicycles example. Let us look on the case when we need to make our bicycles schedulable, this functionality will give as an opportunity to schedule a single bicycle on a specific period. We also need to add ",(0,s.kt)("inlineCode",{parentName:"p"},"leadDays")," property which will store number of days required to prepare the bicycle."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.3"',title:'"Listing','3.3"':!0},"class Schedule {\n  isScheduled(schedulable, starting, ending) {\n    console.log(`Checking if ${schedulable.constructor.name}`\n      + `is available on ${starting} - ${ending}`);\n\n    //do the checks\n\n    return true;\n  }\n}\n\nclass Bicycle {\n  leadDays = 1;\n\n  constructor(parts, schedule = new Schedule()) {\n    this.schedule = schedule;\n    // ...\n  }\n\n  isSchedulable(starting, ending) {\n    const withLeadTime = starting - this.leadDays;\n\n    return this.schedule.isScheduled(this, withLeadTime, ending);\n  }\n}\n")),(0,s.kt)("p",null,"Figure 3.1 - Bicycle classes know if they are schedulable"),(0,s.kt)("img",{width:"700",src:n(5301).Z,alt:"Bicycle classes know if they are schedulable"}),(0,s.kt)("p",null,"Based on the result above and UML-diagram from Figure 3.1 we can say that major part of logic is stored in ",(0,s.kt)("inlineCode",{parentName:"p"},"Schedule")," class, this class is used in ",(0,s.kt)("inlineCode",{parentName:"p"},"isSchedulable")," method, it needs two dates, one for the start and one for the end of booking, ",(0,s.kt)("inlineCode",{parentName:"p"},"Schedule")," instance receives start date with subtracted ",(0,s.kt)("inlineCode",{parentName:"p"},"leadDays"),", so we will always have enough time to prepare the bicycle for a trip. Now we can schedule a bicycle, but we also have other classes like ",(0,s.kt)("inlineCode",{parentName:"p"},"Mechanic")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Driver")," and each of them has its own ",(0,s.kt)("inlineCode",{parentName:"p"},"leadDays")," value. Extracting common logic, we can create ",(0,s.kt)("inlineCode",{parentName:"p"},"Schedulable")," duck type."),(0,s.kt)("p",null,"Figure 3.2 - Schedulable duck type"),(0,s.kt)("img",{width:"700",src:n(7665).Z,alt:"Schedulable duck type"}),(0,s.kt)("p",null,"Let us review UML-diagram from Figure 3.2, we have new ",(0,s.kt)("inlineCode",{parentName:"p"},"Schedulable")," instance, but relation between ",(0,s.kt)("inlineCode",{parentName:"p"},"Bicycle")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Schedulable")," is not ",(0,s.kt)("em",{parentName:"p"},"IS-A"),", because ",(0,s.kt)("inlineCode",{parentName:"p"},"Bicycle")," should not be schedulable under normal conditions. This duck type rather describes ",(0,s.kt)("inlineCode",{parentName:"p"},"Bicycle")," specific behavior when it is required to be scheduled for the trip, or under specific conditions in other words. Other parts of our system should not even know that ",(0,s.kt)("inlineCode",{parentName:"p"},"Bicycle")," is schedulable, these classes relations will be better to describe as ",(0,s.kt)("em",{parentName:"p"},"BEHAVES-AS"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.4"',title:'"Listing','3.4"':!0},"const SchedulableMixin = (superclass) => class extends superclass {\n  private _schedule: Schedule;\n  protected leadDays = 0;\n\n  set schedule(schedule) {\n    this._schedule = schedule;\n  }\n\n  get schedule() {\n    return this._schedule || new Schedule();\n  }\n\n  isSchedulable(starting, ending) {\n    const withLeadDays = starting - this.leadDays;\n\n    return this.schedule.isScheduled(this, withLeadDays, ending);\n  }\n}\n\nclass Bicycle extends SchedulableMixin(Object) {\n  protected leadDays = 1;\n}\n\nclass Vehicle extends SchedulableMixin(Object) {\n  protected leadDays = 3;\n}\n\nclass Mechanic extends SchedulableMixin(Object) {\n  protected leadDays = 4;\n}\n")),(0,s.kt)("p",null,"We have extracted common logic to ",(0,s.kt)("inlineCode",{parentName:"p"},"SchedulableMixin")," with ",(0,s.kt)("inlineCode",{parentName:"p"},"isSchedulable")," method, and now we can easily mix it to any class in our hierarchy, either ",(0,s.kt)("inlineCode",{parentName:"p"},"Bicycle"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"Mechanic")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"Driver"),", so we will have schedulable behavior when we only need it. In this case decorators could be used as an alternative solution, you may know about them from TypeScript, and they solve this problem in as similar manner, so mixins are not the only solution to add a behavior. The only consequence in ",(0,s.kt)("inlineCode",{parentName:"p"},"Schedulable")," mixin is that we need to store ",(0,s.kt)("inlineCode",{parentName:"p"},"leadDays")," property in a target class, so it can be used in mixin."),(0,s.kt)("h2",{id:"34-mixins-writing-inheritable-code"},"3.4 Mixins: Writing Inheritable Code"),(0,s.kt)("p",null,"To better understand which consequences mixins have in general let us review the scheme from Figure 3.3."),(0,s.kt)("p",null,"Figure 3.3 - Mixins call stack"),(0,s.kt)("img",{width:"700",src:n(611).Z,alt:"Mixins call stack"}),(0,s.kt)("p",null,"Taking a closer look at this scheme we can notice that mixins added additional levels to the call stack, this makes understanding and debugging of the application less obvious, so you need to keep this in mind and use mixins only when they are really needed."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Recognize the Antipatterns"),". There are two antipatterns which may indicate that you can gain a benefit from inheritance. First of them is using variables with a type/category to determine a type of object and send it a message. The second is usage of direct object type checking or switch-case operator \u2013 then you rather missed a duck type. Duck types may have not only common interface but also common behavior, which is recommended to extract to mixins."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Insist on the Abstraction"),". All the code in an abstract superclass which should be used in every subclass, superclasses should not contain a code which is only applied for some subclasses. This limitation is also applicable to mixins, all the mixin functionality should be used in every place where it is mixed in. If you cannot identify an abstraction, then probably it is not existing, and inheritance cannot be applied to solve this problem."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Honor the Contract"),". Subclasses must honor the contract, so they can be easily replaced with superclasses without any change in a system behavior. This means that they need to answer on the same messages receiving the same input data and returning the same result data. Thereby they cannot do something which will force a client code to check them for a type to understand what to wait from them. Subclasses which do not honor the contract cannot work synchronously thus making all the inheritance hierarchy unpredictable. This also violates Liskov Substitution Principle which you will learn about in the lecture about SOLID."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Preemptively Decouple Classes"),'. Try to avoid super method call, use template method pattern and so-called hooks instead, they give subclass a possibility to specify the common algorithm which is controlled by superclass. Remember that it is not a "silver bullet" and do not follow this approach blindly.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Create Shallow Hierarchies")," (Figure 3.4). Try to create as compact hierarchies as it is possible. Shallow hierarchies are easy to understand, shallow and wide are slightly more difficult, but they still are easy to understand. Deep and narrow hierarchies tend to become wider and much difficult to understand and maintain. You should avoid deep and wide hierarchies, they create a long path to target method or property which is missing in a target class. Such hierarchies are difficult to maintain, and they create a high risk of application failure.")),(0,s.kt)("p",null,"Figure 3.4 - Hierarchies come in different shapes"),(0,s.kt)("img",{width:"500",src:n(8291).Z,alt:"Hierarchies come in different shapes"}))}p.isMDXComponent=!0},5301:function(e,t,n){t.Z=n.p+"assets/images/bicycle_classes_know_if_they_are_schedulable-1e45f8269951e53b0954299895a8384c.jpg"},8291:function(e,t,n){t.Z=n.p+"assets/images/hierarchies_come_in_different_shapes-94a6487c61686afbbcf35ec8f0c83c88.jpg"},611:function(e,t,n){t.Z=n.p+"assets/images/mixins_call_stack-b225f9d1945c4ce2dcbc46eaba7213ca.jpg"},7665:function(e,t,n){t.Z=n.p+"assets/images/schedulable_duck_type-2a5d2f5edfb6e1889635742c67897bc3.jpg"}}]);