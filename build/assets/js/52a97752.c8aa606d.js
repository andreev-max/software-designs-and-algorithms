"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[9591],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),h=o,f=d["".concat(l,".").concat(h)]||d[h]||p[h]||a;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3589:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={sidebar_position:3},l="2. Creational Design Patterns",c={unversionedId:"design-patterns/creational_design_patterns",id:"design-patterns/creational_design_patterns",title:"2. Creational Design Patterns",description:"Creational patterns as we have already mentioned, provide various object creation mechanisms. We are going to cover three of them: abstract factory, singleton and builder.",source:"@site/docs/5-design-patterns/creational_design_patterns.md",sourceDirName:"5-design-patterns",slug:"/design-patterns/creational_design_patterns",permalink:"/docs/design-patterns/creational_design_patterns",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"1. Design Patterns",permalink:"/docs/design-patterns/design_patterns"},next:{title:"3. Structural Design Patterns",permalink:"/docs/design-patterns/structural_design_patterns"}},u={},p=[{value:"2.1 Abstract Factory",id:"21-abstract-factory",level:2},{value:"2.1.1 Abstract Factory Structure",id:"211-abstract-factory-structure",level:3},{value:"2.1.2 Abstract Factory Example",id:"212-abstract-factory-example",level:3},{value:"2.1.3 When to Apply, Pros and Cons",id:"213-when-to-apply-pros-and-cons",level:3},{value:"2.2 Singleton",id:"22-singleton",level:2},{value:"2.2.1 Singleton Structure",id:"221-singleton-structure",level:3},{value:"2.2.2 Singleton Example",id:"222-singleton-example",level:3},{value:"2.2.3 When to Apply, Pros and Cons",id:"223-when-to-apply-pros-and-cons",level:3},{value:"2.3 Builder",id:"23-builder",level:2},{value:"2.3.1 Builder Structure",id:"231-builder-structure",level:3},{value:"2.3.2 Builder Example",id:"232-builder-example",level:3},{value:"2.3.3 When to Apply, Pros and Cons",id:"233-when-to-apply-pros-and-cons",level:3}],d={toc:p};function h(e){var t=e.components,s=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"2-creational-design-patterns"},"2. Creational Design Patterns"),(0,a.kt)("p",null,"Creational patterns as we have already mentioned, provide various object creation mechanisms. We are going to cover three of them: abstract factory, singleton and builder."),(0,a.kt)("h2",{id:"21-abstract-factory"},"2.1 Abstract Factory"),(0,a.kt)("p",null,"The Abstract Factory  or in simple words \u2013 factory of factories."),(0,a.kt)("p",null,"It provides you an interface for creating objects for each class of the product family. As long as your code creates objects via this interface, you don't have to worry about creating the wrong variant of a product which doesn't match the products already created by your app."),(0,a.kt)("h3",{id:"211-abstract-factory-structure"},"2.1.1 Abstract Factory Structure"),(0,a.kt)("p",null,"Figure 2.1 - Abstract Factory"),(0,a.kt)("img",{width:"700",src:n(2722).Z,alt:"Abstract Factory"}),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Abstract Products declare interfaces for a set of distinct but related products which make up a product family as chair or sofa."),(0,a.kt)("li",{parentName:"ol"},"Concrete Products are various implementations of abstract products, grouped by variants. In this case we implement each abstract product (chair or sofa) in all given variants (Victorian or Modern)."),(0,a.kt)("li",{parentName:"ol"},"The Abstract Factory interface declares a set of methods for creating each of the abstract products."),(0,a.kt)("li",{parentName:"ol"},"Concrete Factories implement creation methods of the abstract factory. Each concrete factory creates only those product variants, that corresponds to a specific variant of products."),(0,a.kt)("li",{parentName:"ol"},"Signatures of concrete factories' creation methods must return corresponding abstract products. In this case the client code that uses a factory doesn't get coupled to the specific variant of the product. The Client can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.")),(0,a.kt)("h3",{id:"212-abstract-factory-example"},"2.1.2 Abstract Factory Example"),(0,a.kt)("p",null,"Here we have 2 kinds of products: door and door fitting master for each type of doors."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.1"',title:'"Listing','2.1"':!0},"interface Door {\n  getDescription();\n}\n\nclass WoodenDoor implements Door {\n  public getDescription() {\n    return 'I am a wooden door';\n  }\n}\n\nclass IronDoor implements Door {\n  public getDescription() {\n    return 'I am a iron door';\n  }\n}\ninterface DoorFittingExpert {\n  getDescription();\n}\n\nclass Welder implements DoorFittingExpert {\n  public getDescription() {\n    return 'I can only fit iron doors';\n  }\n}\n\nclass Carpenter implements DoorFittingExpert {\n  public getDescription() {\n    return 'I can only fit wooden doors';\n  }\n}\n")),(0,a.kt)("p",null,"We declare abstract and concrete products."),(0,a.kt)("p",null,"Next, our abstract factory that would allow us to create a family of related objects:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"wooden door and a carpenter from wooden door factory"),(0,a.kt)("li",{parentName:"ul"},"iron door and a welder from iron door factory")),(0,a.kt)("p",null,"As you can see, the wooden doors' factory contains carpenter's creation and a wooden door, and iron doors' factory contains an iron door and a welder "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.2"',title:'"Listing','2.2"':!0},"interface DoorFactory {\n  makeDoor(): Door;\n  makeFittingExpert(): DoorFittingExpert;\n}\n\nclass WoodenDoorFactory implements DoorFactory {\n  public makeDoor(): Door {\n    return new WoodenDoor();\n  }\n\n  public makeFittingExpert(): DoorFittingExpert {\n    return new Carpenter();\n  }\n}\n\nclass IronDoorFactory implements DoorFactory {\n  public makeDoor(): Door {\n    return new IronDoor();\n  }\n\n  public makeFittingExpert(): DoorFittingExpert {\n    return new Welder();\n  }\n}\n")),(0,a.kt)("p",null,"In this case we make sure, that a client who would use a door factory will get a proper specialist for each of the created doors."),(0,a.kt)("h3",{id:"213-when-to-apply-pros-and-cons"},"2.1.3 When to Apply, Pros and Cons"),(0,a.kt)("p",null,"We should get benefits from usage of the Abstract Factory while working with various families of related products. In this case we are removing the dependency on concrete classes of these products and allowing future extensibility."),(0,a.kt)("p",null,"The abstract factory encapsulates the details of object creation. But client code can still work with all types of created objects, since their interface is initially defined. "),(0,a.kt)("p",null,"Pros"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ensures compatibility of products"),(0,a.kt)("li",{parentName:"ul"},"gets rid of coupling"),(0,a.kt)("li",{parentName:"ul"},"extracts the product creation code into one place. (Single responsibility)"),(0,a.kt)("li",{parentName:"ul"},"introducing new variants without breaking existing code. (Open/Closed)")),(0,a.kt)("p",null,"Cons"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"code becomes more complicated after introducing lots of new interfaces"),(0,a.kt)("li",{parentName:"ul"},"after extending abstract factory interface all concrete factories will need to be updated to implement it")),(0,a.kt)("h2",{id:"22-singleton"},"2.2 Singleton"),(0,a.kt)("p",null,"Singleton is a creational pattern, which means, that the class has only one instance, and it is accessible from any part of application."),(0,a.kt)("h3",{id:"221-singleton-structure"},"2.2.1 Singleton Structure"),(0,a.kt)("p",null,"Figure 2.2 - Singleton"),(0,a.kt)("img",{width:"700",src:n(5865).Z,alt:"Singleton"}),(0,a.kt)("p",null,"Singleton defines static method ",(0,a.kt)("inlineCode",{parentName:"p"},"getInstance()"),", which returns the only instance of its class. The constructor of singleton should be hidden from client code. Calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"getInstance()")," method should be the only way of getting the Singleton object."),(0,a.kt)("p",null,"In other words, the Singleton pattern disables all other means of creating objects of a class except for the special creation method. This method either creates a new object or returns an existing one if it has already been created."),(0,a.kt)("p",null,"Singleton solves two tasks at a time, which violates the single responsibility principle."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"guarantees the existence of single instance of class. It is often useful for accessing common resource, e.g., a database"),(0,a.kt)("li",{parentName:"ul"},"provide a global access point to that instance")),(0,a.kt)("h3",{id:"222-singleton-example"},"2.2.2 Singleton Example"),(0,a.kt)("p",null,"All implementations of the Singleton in general do the same \u2013 they make default constructor private and create public static method, which controls the lifecycle of singleton object. Under the hood, this method calls the private constructor to create an object and saves it in a static field. All following calls to this method return the saved object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.3"',title:'"Listing','2.3"':!0},"class President {\n  private static president: President;\n\n  private constructor() {}\n\n  public static getInstance(): President {\n    if (!President.president) {\n      President.president = new President();\n    }\n\n    return President.president;\n  }\n}\n\nconst president1 = President.getInstance();\nconst president2 = President.getInstance();\n\npresident1 === president2 // true\n")),(0,a.kt)("p",null,"The President is an excellent example of the Singleton pattern. This class doesn't have a public constructor, so the only way to get its instance \u2013 is call ",(0,a.kt)("inlineCode",{parentName:"p"},"getInstance()")," method. This method saves the first created object and will return it in further calls."),(0,a.kt)("h3",{id:"223-when-to-apply-pros-and-cons"},"2.2.3 When to Apply, Pros and Cons"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"if a class in your program should have just a single instance available to all clients; for example, a single database object shared by different parts of the program"),(0,a.kt)("li",{parentName:"ul"},"if you need stricter control over global variables")),(0,a.kt)("p",null,"Pros"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"you can be sure that a class has only a single instance"),(0,a.kt)("li",{parentName:"ul"},"you gain a global access point to that instance"),(0,a.kt)("li",{parentName:"ul"},"the singleton object is initialized only when it's requested for the first time")),(0,a.kt)("p",null,"Cons"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"violates the Single Responsibility Principle"),(0,a.kt)("li",{parentName:"ul"},"pattern can hide bad design"),(0,a.kt)("li",{parentName:"ul"},"requires special handling in a multithreaded environment"),(0,a.kt)("li",{parentName:"ul"},"you will need to think of a creative way to mock the singleton ")),(0,a.kt)("h2",{id:"23-builder"},"2.3 Builder"),(0,a.kt)("p",null,"Builder is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code. In other words: Builder pattern allows creating different parts of object, avoiding overload of constructor. Builder pattern can be used, when object should be built with several parts, or if objects creation takes lots of steps and each of these steps should be configurable."),(0,a.kt)("p",null,"Think of it as dividing an object creation into several steps with different parameters."),(0,a.kt)("h3",{id:"231-builder-structure"},"2.3.1 Builder Structure"),(0,a.kt)("p",null,"Imagine a complex object that requires step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a huge constructor with lots of parameters.  Often most of the parameters will be unused, making the constructor calls ugly."),(0,a.kt)("p",null,"The Builder pattern suggests you extract the object construction code out of its own class and move it to separate objects called ",(0,a.kt)("em",{parentName:"p"},"builders"),". The pattern organizes object construction into a set of steps. To create an object, you execute a series of these steps on a builder object. The important part is that you do not need to call all the steps at a time. You can call only those steps that are necessary for producing a particular configuration of an object."),(0,a.kt)("p",null,"You can go further and extract a series of calls to the builder steps to construct a product into a separate class called ",(0,a.kt)("em",{parentName:"p"},"director"),". The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps."),(0,a.kt)("p",null,"Having a director class in your program is not necessary. You can always call the building steps in a specific order directly from the client code."),(0,a.kt)("p",null,"Figure 2.3 - Builder"),(0,a.kt)("img",{width:"700",src:n(8891).Z,alt:"Builder"}),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The Builder interface declares product construction steps that are common to all types of builders."),(0,a.kt)("li",{parentName:"ol"},"Concrete Builders provide different implementations of the construction steps. Concrete builders may produce products that do not follow the common interface."),(0,a.kt)("li",{parentName:"ol"},"Products are resulting objects. Products constructed by different builders do not have to belong to the same class hierarchy or interface."),(0,a.kt)("li",{parentName:"ol"},"The Director class defines the order in which to call construction steps, so you can create and reuse specific configurations of products."),(0,a.kt)("li",{parentName:"ol"},"The Client must associate one of the builder objects with the director. Usually, it is done just once, via parameters of the director's constructor. Then the director uses that builder object for all further construction. However, there is an alternative approach when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.")),(0,a.kt)("h3",{id:"232-builder-example"},"2.3.2 Builder Example"),(0,a.kt)("p",null,"This example of the Builder pattern illustrates how you can reuse the same object construction code when building diverse types of products, such as cars, and create the corresponding manuals for them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.4"',title:'"Listing','2.4"':!0},"class Car {}\n\ninterface Builder {\n  reset();\n  setSeats(n: Number);\n  setEngine(n: String);\n  setTripComputer(n: Boolean);\n  setGPS(n: Boolean);\n}\n\nclass CarBuilder implements Builder {\n  private car: Car;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() { this.car = new Car(); }\n  setSeats() {}\n  setEngine() {}\n  setTripComputer() {}\n  setGPS() {}\n\n  getProduct(): Car {\n    const product = this.car;\n    this.reset();\n    return product;\n  }\n}\n")),(0,a.kt)("p",null,"A car is a complex object that can be constructed in a hundred diverse ways. Instead of bloating the ",(0,a.kt)("inlineCode",{parentName:"p"},"Car")," class with a huge constructor, we extract the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 2.5"',title:'"Listing','2.5"':!0},"class Director {\n  private builder: Builder;\n\n  setBuilder(b: Builder) {\n    this.builder = b;\n  }\n\n  makeSportCar(b: Builder = this.builder) {\n    b.reset();\n    b.setSeats(2);\n    b.setEngine('V12');\n    b.setTripComputer(true);\n    b.setGPS(true);\n  }\n}\n\nconst director = new Director();\nconst builder = new CarBuilder();\n\ndirector.makeSportCar(builder);\n")),(0,a.kt)("p",null,"If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Director")," class, which knows how to use a builder to construct several of the most popular models of cars."),(0,a.kt)("h3",{id:"233-when-to-apply-pros-and-cons"},"2.3.3 When to Apply, Pros and Cons"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'to get rid of a "telescopic constructor" \u2013 the pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you do not have to cram dozens of parameters into your constructors anymore'),(0,a.kt)("li",{parentName:"ul"},"to construct complex objects \u2013 a builder does not expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result")),(0,a.kt)("p",null,"Pros"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"constructing objects step-by-step, defer construction steps or run steps recursively"),(0,a.kt)("li",{parentName:"ul"},"reusing the same construction code when building various representations of products"),(0,a.kt)("li",{parentName:"ul"},"isolating complex construction code from the business logic of the product")),(0,a.kt)("p",null,"Cons"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"increases complexity of the code since the pattern requires creating multiple new classes"),(0,a.kt)("li",{parentName:"ul"},"client will be bound to concrete builder classes, since builders interface does not have a method for fetching the result of the construction")))}h.isMDXComponent=!0},2722:function(e,t,n){t.Z=n.p+"assets/images/abstract_factory-798820c5169230f1db76b204cc0fb0af.jpg"},8891:function(e,t,n){t.Z=n.p+"assets/images/builder-7b8a2a4b20f8001451071a3d17ca6f7e.jpg"},5865:function(e,t,n){t.Z=n.p+"assets/images/singleton-e08c8050ca9579050178c0bb88773881.jpg"}}]);