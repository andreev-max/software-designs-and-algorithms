"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Introduction","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"\u270b Intro","href":"/docs/Introduction/intro","docId":"Introduction/intro"},{"type":"link","label":"\ud83d\udccd Help","href":"/docs/Introduction/help","docId":"Introduction/help"},{"type":"link","label":"\ud83d\udee0 Importance of TypeScript knowledge for the course","href":"/docs/Introduction/importance-of-TypeScript-knowledge","docId":"Introduction/importance-of-TypeScript-knowledge"}]},{"type":"link","label":"Software Designs and Algorithms: Contents","href":"/docs/contents","docId":"contents"},{"type":"category","label":"2. Building Blocks of OOP, Part 1","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Programming Paradigm","href":"/docs/building-blocks-of-oop-part-1/programming_paradigm","docId":"building-blocks-of-oop-part-1/programming_paradigm"},{"type":"link","label":"2. Unified Modeling Language","href":"/docs/building-blocks-of-oop-part-1/unified_modeling_language","docId":"building-blocks-of-oop-part-1/unified_modeling_language"},{"type":"link","label":"3. Principles of OOP","href":"/docs/building-blocks-of-oop-part-1/principles_of_oop","docId":"building-blocks-of-oop-part-1/principles_of_oop"},{"type":"link","label":"4. Inheritance in Details","href":"/docs/building-blocks-of-oop-part-1/inheritance_in_details","docId":"building-blocks-of-oop-part-1/inheritance_in_details"},{"type":"link","label":"5. Interface","href":"/docs/building-blocks-of-oop-part-1/interface","docId":"building-blocks-of-oop-part-1/interface"},{"type":"link","label":"6. Object-oriented Design Introduction","href":"/docs/building-blocks-of-oop-part-1/object-oriented_design_introduction","docId":"building-blocks-of-oop-part-1/object-oriented_design_introduction"},{"type":"link","label":"7. \ud83d\udcda Home Task","href":"/docs/building-blocks-of-oop-part-1/hometask","docId":"building-blocks-of-oop-part-1/hometask"}]},{"type":"category","label":"3. Building Blocks of OOP, Part 2","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Composition","href":"/docs/building-blocks-of-oop-part-2/composition","docId":"building-blocks-of-oop-part-2/composition"},{"type":"link","label":"2. Duck Typing","href":"/docs/building-blocks-of-oop-part-2/duck_typing","docId":"building-blocks-of-oop-part-2/duck_typing"},{"type":"link","label":"3. Mixins","href":"/docs/building-blocks-of-oop-part-2/mixins","docId":"building-blocks-of-oop-part-2/mixins"},{"type":"link","label":"4. The Law of Demeter","href":"/docs/building-blocks-of-oop-part-2/the_law_of_demeter","docId":"building-blocks-of-oop-part-2/the_law_of_demeter"},{"type":"link","label":"5. Design by Contract","href":"/docs/building-blocks-of-oop-part-2/desing_by_contract","docId":"building-blocks-of-oop-part-2/desing_by_contract"},{"type":"link","label":"6. \ud83d\udcda Home Task","href":"/docs/building-blocks-of-oop-part-2/hometask","docId":"building-blocks-of-oop-part-2/hometask"}]},{"type":"category","label":"4. Functional Programming","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Functional programing (FP)","href":"/docs/functional-programming/general_fp","docId":"functional-programming/general_fp"},{"type":"link","label":"2. Functional language possibilities","href":"/docs/functional-programming/language_possibilities","docId":"functional-programming/language_possibilities"},{"type":"link","label":"3. Main concepts","href":"/docs/functional-programming/main_concepts","docId":"functional-programming/main_concepts"},{"type":"link","label":"4. Functional programing in JS","href":"/docs/functional-programming/is_js_functional","docId":"functional-programming/is_js_functional"},{"type":"link","label":"5. \ud83d\udcda Home Task","href":"/docs/functional-programming/hometask","docId":"functional-programming/hometask"}]},{"type":"category","label":"5. Design Patterns","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Design Patterns","href":"/docs/design-patterns/design_patterns","docId":"design-patterns/design_patterns"},{"type":"link","label":"2. Creational Design Patterns","href":"/docs/design-patterns/creational_design_patterns","docId":"design-patterns/creational_design_patterns"},{"type":"link","label":"3. Structural Design Patterns","href":"/docs/design-patterns/structural_design_patterns","docId":"design-patterns/structural_design_patterns"},{"type":"link","label":"4. Behavioral Design Patterns","href":"/docs/design-patterns/behavioral_design_patterns","docId":"design-patterns/behavioral_design_patterns"},{"type":"link","label":"5. Conclusion","href":"/docs/design-patterns/conclusion","docId":"design-patterns/conclusion"},{"type":"link","label":"6. \ud83d\udcda Home Task","href":"/docs/design-patterns/hometask","docId":"design-patterns/hometask"}]},{"type":"category","label":"6. SOLID Principles","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Introduction","href":"/docs/solid-principles/introduction","docId":"solid-principles/introduction"},{"type":"link","label":"2. SOLID","href":"/docs/solid-principles/solid","docId":"solid-principles/solid"},{"type":"link","label":"3. Anti SOLID","href":"/docs/solid-principles/anti_solid","docId":"solid-principles/anti_solid"},{"type":"link","label":"4. Conclusion","href":"/docs/solid-principles/conclusion","docId":"solid-principles/conclusion"},{"type":"link","label":"5. \ud83d\udcda Home Task","href":"/docs/solid-principles/hometask","docId":"solid-principles/hometask"}]},{"type":"category","label":"7. Algorithms and Data Structures, Part 1","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Elementary Data Structures","href":"/docs/algorithms-and-data-structures-part-1/elementary_data_structures","docId":"algorithms-and-data-structures-part-1/elementary_data_structures"},{"type":"link","label":"2. Binary Search Tree","href":"/docs/algorithms-and-data-structures-part-1/binary_search_tree","docId":"algorithms-and-data-structures-part-1/binary_search_tree"},{"type":"link","label":"3. Red-Black Tree","href":"/docs/algorithms-and-data-structures-part-1/red-black_tree","docId":"algorithms-and-data-structures-part-1/red-black_tree"},{"type":"link","label":"4. B-Trees","href":"/docs/algorithms-and-data-structures-part-1/b-trees","docId":"algorithms-and-data-structures-part-1/b-trees"},{"type":"link","label":"5. Graphs","href":"/docs/algorithms-and-data-structures-part-1/graphs","docId":"algorithms-and-data-structures-part-1/graphs"},{"type":"link","label":"6. \ud83d\udcda Home Task","href":"/docs/algorithms-and-data-structures-part-1/hometask","docId":"algorithms-and-data-structures-part-1/hometask"}]},{"type":"category","label":"8. Algorithms and Data Structures, Part 2","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"1. Algorithms","href":"/docs/algorithms-and-data-structures-part-2/algorithms","docId":"algorithms-and-data-structures-part-2/algorithms"},{"type":"link","label":"2. Insertion Sort","href":"/docs/algorithms-and-data-structures-part-2/insertion_sort","docId":"algorithms-and-data-structures-part-2/insertion_sort"},{"type":"link","label":"3. Divide and Conquer","href":"/docs/algorithms-and-data-structures-part-2/divide_and_conquer","docId":"algorithms-and-data-structures-part-2/divide_and_conquer"},{"type":"link","label":"4. Heap. Heap Sort. Priority Queue","href":"/docs/algorithms-and-data-structures-part-2/heap","docId":"algorithms-and-data-structures-part-2/heap"},{"type":"link","label":"5. Other sorting algorithms","href":"/docs/algorithms-and-data-structures-part-2/other_sorting_algorithms","docId":"algorithms-and-data-structures-part-2/other_sorting_algorithms"},{"type":"link","label":"6. \ud83d\udcda Home Task","href":"/docs/algorithms-and-data-structures-part-2/hometask","docId":"algorithms-and-data-structures-part-2/hometask"}]}]},"docs":{"algorithms-and-data-structures-part-1/b-trees":{"id":"algorithms-and-data-structures-part-1/b-trees","title":"4. B-Trees","description":"B-trees are an immensely powerful tools that are used in SQL and in filesystems. They inherited a loft from red-black trees. Let us figure out what they are and how they work.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-1/binary_search_tree":{"id":"algorithms-and-data-structures-part-1/binary_search_tree","title":"2. Binary Search Tree","description":"This data structure is a bit more interesting. With this data structure it\'s easy to implement a set data type, which is a collection of unique elements. It\'s also easy to implement operations such as search, finding min or max element in the set and search of previous and next values. All those operations take O(logn) time if the tree is balanced.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-1/elementary_data_structures":{"id":"algorithms-and-data-structures-part-1/elementary_data_structures","title":"1. Elementary Data Structures","description":"This is a finishing part of this course and the last lecture dedicated to data structures and algorithms performed on them. At first, it is better to start with the most simple data structures that implement last in, first out (LIFO) and first in, first out (FIFO) principles.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-1/graphs":{"id":"algorithms-and-data-structures-part-1/graphs","title":"5. Graphs","description":"Finishing theme of this lecture will be about graphs. All types of trees we looked at in this lecture are special cases of graphs. A graph is a data structure, that consists of finite set of vertices, together with a set of unordered pairs of these vertices for an undirected graph or a set of ordered pairs for a directed graph. These pairs are known as edges.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-1/hometask":{"id":"algorithms-and-data-structures-part-1/hometask","title":"6. \ud83d\udcda Home Task","description":"The home task should be done using TypeScript.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-1/red-black_tree":{"id":"algorithms-and-data-structures-part-1/red-black_tree","title":"3. Red-Black Tree","description":"A red-black tree is a binary search tree with one extra bit of storage per node: its color, which can be either RED or BLACK. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately balanced.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-2/algorithms":{"id":"algorithms-and-data-structures-part-2/algorithms","title":"1. Algorithms","description":"So, what is algorithm? Non-programmers joke, that this is a word used by programmers when they do not want to explain what they did.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-2/divide_and_conquer":{"id":"algorithms-and-data-structures-part-2/divide_and_conquer","title":"3. Divide and Conquer","description":"We can choose from a wide range of algorithm design techniques. For insertion sort, we used an incremental approach: having sorted the subarray A[1 .. j-1], we inserted the single element A[j] into its proper place, yielding the sorted subarray A[1 .. j].","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-2/heap":{"id":"algorithms-and-data-structures-part-2/heap","title":"4. Heap. Heap Sort. Priority Queue","description":"The (binary) heap data structure is an array object that we can view as a nearly complete binary tree. Each node of the tree corresponds to an element of the array. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point. An array A that represents a heap is an object with two attributes","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-2/hometask":{"id":"algorithms-and-data-structures-part-2/hometask","title":"6. \ud83d\udcda Home Task","description":"The home task should be done using TypeScript.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-2/insertion_sort":{"id":"algorithms-and-data-structures-part-2/insertion_sort","title":"2. Insertion Sort","description":"Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.","sidebar":"tutorialSidebar"},"algorithms-and-data-structures-part-2/other_sorting_algorithms":{"id":"algorithms-and-data-structures-part-2/other_sorting_algorithms","title":"5. Other sorting algorithms","description":"There are many other sorting algorithms. The following table provides an overview of some sorting algorithms. It is a selection of the most common sorting algorithms.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/hometask":{"id":"building-blocks-of-oop-part-1/hometask","title":"7. \ud83d\udcda Home Task","description":"The home task should be done using TypeScript.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/inheritance_in_details":{"id":"building-blocks-of-oop-part-1/inheritance_in_details","title":"4. Inheritance in Details","description":"4.1 Intro","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/interface":{"id":"building-blocks-of-oop-part-1/interface","title":"5. Interface","description":"As mentioned earlier, OOP is directly related to messages sent between objects. Moreover, it is important not only what objects know what behavior they have inside, on whom they depend (to whom messages are sent), but also how they communicate with each other. Objects communicate through interfaces.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/object-oriented_design_introduction":{"id":"building-blocks-of-oop-part-1/object-oriented_design_introduction","title":"6. Object-oriented Design Introduction","description":"Object-oriented design is the process of planning a system of interacting objects for the purpose of solving a software problem. It is one approach to software design.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/principles_of_oop":{"id":"building-blocks-of-oop-part-1/principles_of_oop","title":"3. Principles of OOP","description":"We are done with the introductory part, let us move on to the principles of object-oriented programming. We will consider four basic principles of OOP on which the object-oriented concept, object-oriented programming is based: abstraction, polymorphism, encapsulation, and inheritance. In some sources, more concepts are highlighted, for example, Wikipedia still refers to the fundamental concepts of object-oriented programming such concepts as class and object. But these four concepts are the classics on which the concept of object-oriented programming is based.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/programming_paradigm":{"id":"building-blocks-of-oop-part-1/programming_paradigm","title":"1. Programming Paradigm","description":"This lecture is going to be dedicated to object-oriented programming and object-oriented design. It is going to be an overview lecture of what you are going to learn in this course, but I recommend you pay close attention to it. The reason being, it is going to include a lot of basics and principles that will help you write better, cleaner, more maintainable code.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-1/unified_modeling_language":{"id":"building-blocks-of-oop-part-1/unified_modeling_language","title":"2. Unified Modeling Language","description":"2.1 What is UML","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-2/composition":{"id":"building-blocks-of-oop-part-2/composition","title":"1. Composition","description":"1.1 What is the Composition","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-2/desing_by_contract":{"id":"building-blocks-of-oop-part-2/desing_by_contract","title":"5. Design by Contract","description":"5.1 Correctness","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-2/duck_typing":{"id":"building-blocks-of-oop-part-2/duck_typing","title":"2. Duck Typing","description":"2.1 If It Walks Like a Duck and Talks Like a Duck Then It\'s a Duck","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-2/hometask":{"id":"building-blocks-of-oop-part-2/hometask","title":"6. \ud83d\udcda Home Task","description":"The home task should be done using TypeScript.","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-2/mixins":{"id":"building-blocks-of-oop-part-2/mixins","title":"3. Mixins","description":"3.1 Sharing Role Behavior with Mixins","sidebar":"tutorialSidebar"},"building-blocks-of-oop-part-2/the_law_of_demeter":{"id":"building-blocks-of-oop-part-2/the_law_of_demeter","title":"4. The Law of Demeter","description":"The purpose of the law of Demeter is lower cohesion. The low cohesion shows that the design is of good quality. In short, the law of Demeter sounds like this:","sidebar":"tutorialSidebar"},"contents":{"id":"contents","title":"Software Designs and Algorithms: Contents","description":"- Building Blocks of OOP, Part 1","sidebar":"tutorialSidebar"},"design-patterns/behavioral_design_patterns":{"id":"design-patterns/behavioral_design_patterns","title":"4. Behavioral Design Patterns","description":"Behavioral design patterns are related to algorithms and the assignment of responsibilities between objects. They can be based on both \u2013 inheritance and composition.","sidebar":"tutorialSidebar"},"design-patterns/conclusion":{"id":"design-patterns/conclusion","title":"5. Conclusion","description":"You may successfully code without having an idea of what patterns are. Moreover, you might have implemented some of them without even noticing. But conscious usage of tool differs is an important step from a beginner level to professional. You may hammer a nail, and you may hit it with a drill as well, if you make enough effort. Professional developer understands, that it\'s not a purpose of a drill.","sidebar":"tutorialSidebar"},"design-patterns/creational_design_patterns":{"id":"design-patterns/creational_design_patterns","title":"2. Creational Design Patterns","description":"Creational patterns as we have already mentioned, provide various object creation mechanisms. We are going to cover three of them: abstract factory, singleton and builder.","sidebar":"tutorialSidebar"},"design-patterns/design_patterns":{"id":"design-patterns/design_patterns","title":"1. Design Patterns","description":"Design pattern is a commonly used solution for a specific problem in software design. Unlike developed functions or libraries, pattern cannot be just copied to the code. It\'s not an already made piece of software, but a general conception of solution for the problem, which has to be adjusted and implemented in your software.","sidebar":"tutorialSidebar"},"design-patterns/hometask":{"id":"design-patterns/hometask","title":"6. \ud83d\udcda Home Task","description":"The home task should be done using TypeScript.","sidebar":"tutorialSidebar"},"design-patterns/structural_design_patterns":{"id":"design-patterns/structural_design_patterns","title":"3. Structural Design Patterns","description":"Structural patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient. To achieve that, both inheritance and composition can be applied.","sidebar":"tutorialSidebar"},"functional-programming/general_fp":{"id":"functional-programming/general_fp","title":"1. Functional programing (FP)","description":"Functional programming is a programming paradigm, that is another, different than OOP, way of thinking about how to build the application. The main unit of functional programming is a function. We already use functions on daily basis so what is the difference in this case? To use FP we have to think differently, the aim is to abstract control flows and operations on data with functions, so by doing that we could avoid side effects and reduce mutation of state.","sidebar":"tutorialSidebar"},"functional-programming/hometask":{"id":"functional-programming/hometask","title":"5. \ud83d\udcda Home Task","description":"The home task should be done using TypeScript.","sidebar":"tutorialSidebar"},"functional-programming/is_js_functional":{"id":"functional-programming/is_js_functional","title":"4. Functional programing in JS","description":"4.1 Functional concepts in JS","sidebar":"tutorialSidebar"},"functional-programming/language_possibilities":{"id":"functional-programming/language_possibilities","title":"2. Functional language possibilities","description":"There are several functional languages in there: Scala, Clojure, Lisp, Haskel, etc.","sidebar":"tutorialSidebar"},"functional-programming/main_concepts":{"id":"functional-programming/main_concepts","title":"3. Main concepts","description":"3.1 Immutability","sidebar":"tutorialSidebar"},"Introduction/help":{"id":"Introduction/help","title":"\ud83d\udccd Help","description":"How to Study the Course","sidebar":"tutorialSidebar"},"Introduction/importance-of-TypeScript-knowledge":{"id":"Introduction/importance-of-TypeScript-knowledge","title":"\ud83d\udee0 Importance of TypeScript knowledge for the course","description":"There is an expectation that participants of the course know TypeScript on the basic level. Almost all code snippets presented in the course are written in TypeScript. So, why is TypeScript important for the course?","sidebar":"tutorialSidebar"},"Introduction/intro":{"id":"Introduction/intro","title":"\u270b Intro","description":"Necessary knowledge","sidebar":"tutorialSidebar"},"solid-principles/anti_solid":{"id":"solid-principles/anti_solid","title":"3. Anti SOLID","description":"Let us summarize all the information we got about SOLID principles and talk about anti SOLID behavior that you might have faced.","sidebar":"tutorialSidebar"},"solid-principles/conclusion":{"id":"solid-principles/conclusion","title":"4. Conclusion","description":"In this lesson you have learnt about SOLID principles that are commonly used in development and software design. These are 5 essential principles used by software engineers all around the globe, and if you are serious about creating solid software, you should start applying these principles today!","sidebar":"tutorialSidebar"},"solid-principles/hometask":{"id":"solid-principles/hometask","title":"5. \ud83d\udcda Home Task","description":"1. Identify SOLID Principles","sidebar":"tutorialSidebar"},"solid-principles/introduction":{"id":"solid-principles/introduction","title":"1. Introduction","description":"In this section you are going to learn about SOLID principles that are commonly used in development and software design. You will study each of the principles in details, review examples of their usage and violations. As a result, you will understand why SOLID principles are needed and whether they are needed at all.","sidebar":"tutorialSidebar"},"solid-principles/solid":{"id":"solid-principles/solid","title":"2. SOLID","description":"2.1 Single Responsibility Principle (SRP)","sidebar":"tutorialSidebar"}}}')}}]);