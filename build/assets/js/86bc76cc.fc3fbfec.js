"use strict";(self.webpackChunksoftware_designs_and_algorithms=self.webpackChunksoftware_designs_and_algorithms||[]).push([[8615],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),u=a,f=c["".concat(s,".").concat(u)]||c[u]||h[u]||i;return n?r.createElement(f,o(o({ref:t},d),{},{components:n})):r.createElement(f,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5235:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return h}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],l={sidebar_position:4},s="3. Red-Black Tree",p={unversionedId:"algorithms-and-data-structures-part-1/red-black_tree",id:"algorithms-and-data-structures-part-1/red-black_tree",title:"3. Red-Black Tree",description:"A red-black tree is a binary search tree with one extra bit of storage per node: its color, which can be either RED or BLACK. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately balanced.",source:"@site/docs/7-algorithms-and-data-structures-part-1/red-black_tree.md",sourceDirName:"7-algorithms-and-data-structures-part-1",slug:"/algorithms-and-data-structures-part-1/red-black_tree",permalink:"/docs/algorithms-and-data-structures-part-1/red-black_tree",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"2. Binary Search Tree",permalink:"/docs/algorithms-and-data-structures-part-1/binary_search_tree"},next:{title:"4. B-Trees",permalink:"/docs/algorithms-and-data-structures-part-1/b-trees"}},d={},h=[{value:"3.1 Insert and Delete",id:"31-insert-and-delete",level:2}],c={toc:h};function u(e){var t=e.components,l=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"3-red-black-tree"},"3. Red-Black Tree"),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"red-black tree")," is a binary search tree with one extra bit of storage per node: its color, which can be either RED or BLACK. By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately ",(0,i.kt)("strong",{parentName:"p"},"balanced"),"."),(0,i.kt)("p",null,"Each node of the tree now contains the attributes ",(0,i.kt)("em",{parentName:"p"},"color"),", ",(0,i.kt)("em",{parentName:"p"},"key"),", ",(0,i.kt)("em",{parentName:"p"},"left"),", ",(0,i.kt)("em",{parentName:"p"},"right"),", and ",(0,i.kt)("em",{parentName:"p"},"p"),". If a child or the parent of a node does not exist, the corresponding pointer attribute of the node contains the value ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". We shall regard these ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"s as being pointers to leaves (external nodes) of the binary search tree and the normal, key-bearing nodes as being internal nodes of the tree."),(0,i.kt)("p",null,"A red-black tree is a binary tree that satisfies the following ",(0,i.kt)("strong",{parentName:"p"},"red-black properties"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Every node is either red or black."),(0,i.kt)("li",{parentName:"ul"},"The root is black"),(0,i.kt)("li",{parentName:"ul"},"Every leaf (",(0,i.kt)("inlineCode",{parentName:"li"},"null"),") is black"),(0,i.kt)("li",{parentName:"ul"},"If a node is red, then both its children are black"),(0,i.kt)("li",{parentName:"ul"},"For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.")),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"A red-black tree also has a lemma: a tree with ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," internal nodes has height at most ",(0,i.kt)("inlineCode",{parentName:"p"},"2lg(n + 1)"),'. The proof of this lemma can be found in a book called "Algorithms + Data Structures = Programs" written by Niklaus Wirth.'))),(0,i.kt)("p",null,"This is how a red-black tree looks."),(0,i.kt)("p",null,"Figure 3.1"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Red-black tree",src:n(4590).Z,width:"936",height:"280"})),(0,i.kt)("h2",{id:"31-insert-and-delete"},"3.1 Insert and Delete"),(0,i.kt)("p",null,"The search-tree operations ",(0,i.kt)("strong",{parentName:"p"},"TREE-INSERT")," and ",(0,i.kt)("strong",{parentName:"p"},"TREE-DELETE"),", when run on a red-black tree with ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," keys, take ",(0,i.kt)("inlineCode",{parentName:"p"},"O(lgn)")," time. Because they modify the tree, the result may violate the red-black properties. To restore these properties, we must change the colors of some nodes in the tree and also change the pointer structure."),(0,i.kt)("p",null,"Figure 3.2"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Tree rotation",src:n(296).Z,width:"756",height:"236"})),(0,i.kt)("p",null,"We change the pointer structure through ",(0,i.kt)("strong",{parentName:"p"},"rotation"),", which is a local operation in a search tree that preserves the binary-search-tree property. Image below shows the two kinds of rotations: left rotations and right rotations. When we do a left rotation on a node ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", we assume that its right child ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"; ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," may be any node in the tree whose right child is not ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),'. The left rotation "pivots" around the link from ',(0,i.kt)("inlineCode",{parentName:"p"},"x")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),". It makes ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," the new root of the subtree, with ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"s left child and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"s left child as ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"s right child."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.1 - rotateLeft and rotateRight"',title:'"Listing',3.1:!0,"-":!0,rotateLeft:!0,and:!0,'rotateRight"':!0},"rotateLeft() {\n  let y = this.right;\n  this.right = y.left;\n\n  if (!y.left.isNil) {\n    y.left.parent = this;\n  }\n\n  if (!y.isNil) y.parent = this.parent;\n\n  if (this.parent) {\n    if (this.id == this.parent.left.id) {\n      this.parent.left = y;\n    } else {\n      this.parent.right = y;\n    }\n  } else {\n    this.tree.root = y;\n  }\n\n  y.left = this;\n  if (!this.isNil) this.parent = y;\n},\nrotateRight() {\n  let y = this.left;\n  this.left = y.right;\n\n  if (!y.right.isNil) {\n    y.right.parent = this;\n  }\n\n  if (!y.isNil) y.parent = this.parent;\n\n  if (this.parent) {\n    if (this.id == this.parent.right.id) {\n      this.parent.right = y;\n    } else {\n      this.parent.left = y;\n    }\n  } else {\n    this.tree.root = y;\n  }\n\n  y.right = this;\n  if (!this.isNil) this.parent = y;\n}\n")),(0,i.kt)("p",null,"This is how methods of left and right rotation are defined. They are completely symmetrical."),(0,i.kt)("p",null,"Figure 3.3"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Tree rotation",src:n(4026).Z,width:"878",height:"618"})),(0,i.kt)("p",null,"Here is a visualization of a rotation. In this example, we are rotating element ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," in a tree ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," left. After a rotation, the ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),' element "pulls" its right subtree up (elements 19, 20, 22). Left subtree of ',(0,i.kt)("inlineCode",{parentName:"p"},"x")," (9) stays the same, and left subtree of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," becomes right subtree of ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.2 - insertNode"',title:'"Listing',3.2:!0,"-":!0,'insertNode"':!0},"insertNode(data) {\n  let current, parent, x;\n  current = this.root;\n  parent = null;\n\n  while (!current.isNil) {\n    if (data == current.value) return current;\n\n    parent = current;\n    current = data < current.value ? current.left : current.right;\n  }\n\n  x = new rbNode(this);\n  x.value = data;\n  x.parent = parent;\n  x.isRed = true;\n  x.isNil = false;\n\n  x.left = new rbNode(this);\n  x.right = new rbNode(this);\n\n  if (parent) {\n    if (x.value < parent.value) {\n      parent.left = x;\n    } else {\n      parent.right = x;\n    }\n  } else {\n    this.root = x;\n  }\n\n  this.insertFixup(x);\n\n  return x;\n}\n")),(0,i.kt)("p",null,"To insert a node, first we have to find a place to insert it into. The new node will always be added as a leaf. This means that both of his children are NIL and are black. The newly added node will always be red. After insertion, we perform a ",(0,i.kt)("inlineCode",{parentName:"p"},"insertFixup")," operation defined as following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Listing 3.3 - insertFixup"',title:'"Listing',3.3:!0,"-":!0,'insertFixup"':!0},"insertFixup(x) {\n  while (x.id != this.root.id && x.parent.isRed) {\n    if (x.parent.id == x.parent.parent.left.id) {\n      let y = x.parent.parent.right;\n\n      if (y.isRed) {\n        x.parent.isRed = false;\n        y.isRed = false;\n        x.parent.parent.isRed = true;\n        x = x.parent.parent;\n      } else {\n        if (x.id == x.parent.right.id) {\n          x = x.parent;\n          x.rotateLeft();\n        }\n\n        x.parent.isRed = false;\n        x.parent.parent.isRed = true;\n        x.parent.parent.rotateRight();\n      }\n    } else {\n      let y = x.parent.parent.left;\n\n      if (y.isRed) {\n        x.parent.isRed = false;\n        y.isRed = false;\n        x.parent.parent.isRed = true;\n        x = x.parent.parent;\n      } else {\n        if (x.id == x.parent.left.id) {\n          x = x.parent;\n          x.rotateRight();\n        }\n\n        x.parent.isRed = false;\n        x.parent.parent.isRed = true;\n        x.parent.parent.rotateLeft();\n      }\n    }\n  }\n\n  this.root.isRed = false;\n}\n")),(0,i.kt)("p",null,"To perform the fixup, we have to look at the parent, and check if the red-black property is followed. If the parent node is black \u2013 we can exit. If it is red, we recolor it black and preform a rotation to balance the tree. By inserting a red node with 2 NIL-children, we are keeping the property of black height (property 4). Although, this could mean that we are breaking the property 3, according to which both children of a red node have to be black. So, let's look at a situation when a parent of a new node is red, by which the property 3 will be violated."),(0,i.kt)("p",null,"Let's look at 2 different cases:"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},'Case 1: Red parent, red "uncle".'),' This is called red-red violation. The new node X has a red parent and a red "uncle" (the other sibling of parents\' parent). A simple recolor will fix the red-red violation. After recoloring, we must check the "grandparent" of the new node because it could be red. Look at how the new red node influences nodes at the top. At the end we recolor the root node black. If it was red before, we increase the black height of the tree.'),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},'Case 2: Red parent, black "uncle".'),' This is the other case of red-red violation \u2013 the "uncle" of the new node is black. Here, the nodes could be rotated to correct the subtrees. At this point, the algorithm could exit because there are no red-red violations, and the root of the tree is painted black. Please note, that if the node ',(0,i.kt)("inlineCode",{parentName:"p"},"x")," was the right sibling, then at first, the left rotation will be applied. It will make the new node the left sibling. Every correction, performed at insertion makes us go up a tree by one level."),(0,i.kt)("p",null,"The deletion of a node is analogous to insertion, but instead of looking at the uncle node, we look at the sibling of the deleted node. If you want to learn more about deletion, please look it ",(0,i.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/"},"here"),"."),(0,i.kt)("p",null,"Let us look at an example of insertion of a node."),(0,i.kt)("p",null,"Figure 3.4"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Node insertion",src:n(9185).Z,width:"674",height:"442"})),(0,i.kt)("p",null,"Figure 3.5"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Node insertion",src:n(3149).Z,width:"704",height:"408"})),(0,i.kt)("p",null,"At first (a), we insert a node ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," with value 4. It's inserted red, the parent of it is red and the uncle ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," is red too. To fix this red-red violation, we recolor the parent of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," to black and make the parent red (transition a-b)."),(0,i.kt)("p",null,"Now, we have a red-red violation, and we assume the previous grandparent node of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," (7) as ",(0,i.kt)("inlineCode",{parentName:"p"},"z"),". At this point, the uncle of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," \u2013 ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," would be node 14. To fix this red-red violation, we perform a left-rotate on parent of the node ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," (transition b-c)."),(0,i.kt)("p",null,"At this point we assume that the previous parent of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," (node 2) and its uncle ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is 14. The node 7 is still red, and we have the red-red violation. To fix it, we have to recolor parent of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," to black, recolor grandparent of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," to red and perform a right rotation on grandparent (transition c-b). At this point, since the parent element of ",(0,i.kt)("inlineCode",{parentName:"p"},"z")," is black, we can be sure that the tree is balanced."))}u.isMDXComponent=!0},9185:function(e,t,n){t.Z=n.p+"assets/images/node_insertion1-c36b5f45b2f19f111ad9a460c243c9cc.jpg"},3149:function(e,t,n){t.Z=n.p+"assets/images/node_insertion2-ae12d1585fdb28a95f8349707a036e27.jpg"},4590:function(e,t,n){t.Z=n.p+"assets/images/red-black_tree-26eaa86dc882a0859897b0c762df3c26.jpg"},296:function(e,t,n){t.Z=n.p+"assets/images/tree_rotation1-07d5b8a10773ee5fbafd019fb4a85005.jpg"},4026:function(e,t,n){t.Z=n.p+"assets/images/tree_rotation2-72c86f677c17ff55a3bdf2d0341d2eff.jpg"}}]);