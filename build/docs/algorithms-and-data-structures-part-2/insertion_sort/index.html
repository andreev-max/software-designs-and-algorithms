<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-algorithms-and-data-structures-part-2/insertion_sort">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<title data-rh="true">2. Insertion Sort | Software Designs and Algorithms</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/docs/algorithms-and-data-structures-part-2/insertion_sort"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="2. Insertion Sort | Software Designs and Algorithms"><meta data-rh="true" name="description" content="Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part."><meta data-rh="true" property="og:description" content="Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/docs/algorithms-and-data-structures-part-2/insertion_sort"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/algorithms-and-data-structures-part-2/insertion_sort" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/docs/algorithms-and-data-structures-part-2/insertion_sort" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.4e6bc769.css">
<link rel="preload" href="/assets/js/runtime~main.35869dc7.js" as="script">
<link rel="preload" href="/assets/js/main.0213352a.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Software Designs and Algorithms" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="Software Designs and Algorithms" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Software Designs and Algorithms</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/contents">Start learning</a><a class="navbar__item navbar__link" href="/docs/Introduction/help">Help</a></div><div class="navbar__items navbar__items--right"><a href="https://git.epam.com/viktor_soroka/software-designs-and-algorithms" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Gitlab<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/Introduction/intro">Introduction</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/contents">Software Designs and Algorithms: Contents</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/building-blocks-of-oop-part-1/programming_paradigm">2. Building Blocks of OOP, Part 1</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/building-blocks-of-oop-part-2/composition">3. Building Blocks of OOP, Part 2</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/functional-programming/general_fp">4. Functional Programming</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/design-patterns/design_patterns">5. Design Patterns</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/solid-principles/introduction">6. SOLID Principles</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/algorithms-and-data-structures-part-1/elementary_data_structures">7. Algorithms and Data Structures, Part 1</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/algorithms-and-data-structures-part-2/algorithms">8. Algorithms and Data Structures, Part 2</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/algorithms-and-data-structures-part-2/algorithms">1. Algorithms</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/algorithms-and-data-structures-part-2/insertion_sort">2. Insertion Sort</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/algorithms-and-data-structures-part-2/divide_and_conquer">3. Divide and Conquer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/algorithms-and-data-structures-part-2/heap">4. Heap. Heap Sort. Priority Queue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/algorithms-and-data-structures-part-2/other_sorting_algorithms">5. Other sorting algorithms</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/algorithms-and-data-structures-part-2/hometask">6. 📚 Home Task</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">8. Algorithms and Data Structures, Part 2</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">2. Insertion Sort</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>2. Insertion Sort</h1><p>Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.</p><p>To sort an array of size n in ascending order (Figure 2.1):</p><ul><li>Iterate from <code>arr[1]</code> to <code>arr[n]</code> over the array.</li><li>Compare the current element (key) to its predecessor.</li><li>If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.</li></ul><p>Figure 2.1</p><p><img loading="lazy" alt="img.png" src="/assets/images/insertion_sort-78506de5d6e4323dc0102c909c332e80.png" width="458" height="631" class="img_ev3q"></p><p>The running time of the <code>insertionSort</code> procedure depends on the set of input values: it takes longer to sort thousands of numbers than to sort three numbers. In the general case, the running time of the algorithm increases with an increase in the amount of input data, so it is a common practice to represent the running time of a program as a function depending on the number of input elements. For this, the concepts of &quot;algorithm time&quot; and &quot;size of input data&quot; need to be determined more precisely.</p><p>The most adequate concept of input data size depends on the problem in question. For each task considered below, the way of measuring the size of the input data will be indicated. In the case of insertion sort, the number of input elements is considered as the size of the input data.</p><p>The running time of an algorithm on a particular input is the number of primitive operations or &quot;steps&quot; executed. It is convenient to define the notion of step so that it is as machine-independent as possible. For the moment, let us adopt the following view. A constant amount of time is required to execute each line of our code.</p><p>In the following discussion, our expression for the running time of insertion sort will evolve from a messy formula that uses all the statement costs <em>c<sub>i</sub></em> to a much simpler notation that is more concise and more easily manipulated. This simpler notation will also make it easy to determine whether one algorithm is more efficient than another.</p><p>To begin with, we introduce for the insertionSort procedure a time &quot;cost&quot; of each instruction and the number of their repetitions. Let <code>t<sub>j</sub></code> be the number of condition checks in the while loop. If the for and while loops are completed normally (that is, when the condition specified in the loop header ceases to be met), the condition is checked for one more time than the loop body is executed.</p><p>Listing 2.1 - Insertion sort</p><iframe title="Insertion sort" src="https://codesandbox.io/embed/insertion-sort-p4g1bn?expanddevtools=1&amp;fontsize=14&amp;hidenavigation=1&amp;theme=dark" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>This is the insertion sort implementation, but we have placed the <code>C</code> with the index and the number of repetitions how many times we pay this price.</p><p>The running time of the algorithm is the sum of running times for each statement executed; a statement that takes <code>c<sub>i</sub></code> steps to execute and executes <code>n</code> times will contribute <code>c<sub>i</sub>n</code> to the total running time. To compute <code>T(n)</code> the running time of <code>insertionSort</code> on an input of <code>n</code> values, we sum the products of the cost and times columns, obtaining:</p><div class="formula"><img loading="lazy" src="https://latex.codecogs.com/svg.image?\begin{document}\color{black}T(n)=c_{1}n&amp;plus;c_{2}(n-1)&amp;plus;c_{3}(n-1)&amp;plus;c_{4}\sum_{j=2}^{n}t_{j}&amp;plus;c_{5}\sum_{j=2}^{n}(t_{j}-1)&amp;plus;c_{6}\sum_{j=2}^{n}(t_{j}-1)&amp;plus;c_{7}(n-1)\end{document}" title="\begin{document}\color{black}T(n)=c_{1}n+c_{2}(n-1)+c_{3}(n-1)+c_{4}\sum_{j=2}^{n}t_{j}+c_{5}\sum_{j=2}^{n}(t_{j}-1)+c_{6}\sum_{j=2}^{n}(t_{j}-1)+c_{7}(n-1)\end{document}" class="img_ev3q"></div><p>Even for inputs of a given size, an algorithm&#x27;s running time may depend on which input of that size is given. For example, in <code>insertionSort</code>, the best case occurs if the array is already sorted. For each <code>j = 2, 3, …, n</code> we then find that <code>A<sub>i</sub> ≤ key</code> in line 4 when <code>i</code> has its initial value of <code>j-1</code>. Thus, <code>t<sub>j</sub>=1</code> for <code>j=2, 3, …, n</code> and the best-case running time is:</p><div class="formula"><img loading="lazy" src="https://latex.codecogs.com/svg.image?\begin{multline*}\color{black}T(n)=c_{1}n&amp;plus;c_{2}(n-1)&amp;plus;c_{3}(n-1)&amp;plus;c_{4}(n-1)&amp;plus;c_{7}(n-1)=\\(c_{1}&amp;plus;c_{2}&amp;plus;c_{3}&amp;plus;c_{4}&amp;plus;c_{7})n-(c_{2}&amp;plus;c_{3}&amp;plus;c_{4}&amp;plus;c_{7})\end{multline*}" title="\begin{multline*}\color{black}T(n)=c_{1}n+c_{2}(n-1)+c_{3}(n-1)+c_{4}(n-1)+c_{7}(n-1)=\\(c_{1}+c_{2}+c_{3}+c_{4}+c_{7})n-(c_{2}+c_{3}+c_{4}+c_{7})\end{multline*}" class="img_ev3q"></div><p>We can express this running time as <code>an + b</code> for constants <code>a</code> and <code>b</code> that depend on the statement costs <code>c<sub>i</sub></code>. It is thus a linear function of <em>n</em>.
If the array is in reverse sorted order - that is, in decreasing order - the worst case results. We must compare each element <code>A<sub>i</sub></code> with each element in the entire sorted subarray <code>A<sub>1..j-1</sub></code>, and so <code>t<sub>j</sub>=j</code> for <code>j=2, 3, …, n</code>. The worst case, the running time of <code>insertionSort</code> is:</p><div class="formula"><img loading="lazy" src="https://latex.codecogs.com/svg.image?\begin{multline*}\color{black}T(n)=c_{1}n&amp;plus;c_{2}(n-1)&amp;plus;c_{3}(n-1)&amp;plus;c_{4}(\frac{n(n-1)}{2}-1)&amp;plus;c_{5}(\frac{n(n-1)}{2})&amp;plus;c_{6}(\frac{n(n-1)}{2})=\\\frac{c_{4}&amp;plus;c_{5}&amp;plus;c_{6}}{2}n^2&amp;plus;(c_{1}&amp;plus;c_{2}&amp;plus;c_{3}&amp;plus;\frac{c_{4}-c_{5}-c_{6}}{2}&amp;plus;c_{8})n-(c_{2}&amp;plus;c_{3}&amp;plus;c_{4}&amp;plus;c_{7})\end{multline*}" title="\begin{multline*}\color{black}T(n)=c_{1}n+c_{2}(n-1)+c_{3}(n-1)+c_{4}(\frac{n(n-1)}{2}-1)+c_{5}(\frac{n(n-1)}{2})+c_{6}(\frac{n(n-1)}{2})=\\\frac{c_{4}+c_{5}+c_{6}}{2}n^2+(c_{1}+c_{2}+c_{3}+\frac{c_{4}-c_{5}-c_{6}}{2}+c_{8})n-(c_{2}+c_{3}+c_{4}+c_{7})\end{multline*}" class="img_ev3q"></div><p>We can express this worst-case running time as an^2+bn+c for constants a, b, and c that again depend on the statement costs <code>c<sub>i</sub></code>. It is thus a <strong>quadratic function</strong> of <code>n</code>.</p><p>In our analysis of insertion sort, we looked at both the best case, in which the input array was already sorted, and the worst case, in which the input array was reverse sorted. For the remainder of this book, though, we shall usually concentrate on finding only the worst-case running time, that is, the longest running time for any input of size <code>n</code>. We give three reasons for this orientation.</p><p>The worst-case running time of an algorithm gives us an upper bound on the running time for any input. Knowing it provides a guarantee that the algorithm will never take any longer. We need not make some educated guess about the running time and hope that it never gets much worse.</p><p>For some algorithms, the worst case occurs fairly often. For example, in searching a database for a particular piece of information, the searching algorithm&#x27;s worst case will often occur when the information is not present in the database. In some applications, searches for absent information may be frequent.</p><p>The &quot;average case&quot; is often roughly as bad as the worst case. Suppose that we randomly choose n numbers and apply insertion sort. How long does it take to determine where in subarray <code>A<sub>(1..j-1)</sub></code> to insert element <code>A<sub>j</sub></code>? On average, half the elements in <code>A<sub>(1..j-1)</sub></code> are less than <code>A<sub>j</sub></code>, and half the elements are greater. On average, therefore, we check half of the <code>A<sub>(1..j-1)</sub></code>, and so <code>t<sub>j</sub></code> is about <code>j/2</code>. The resulting average-case running time turns out to be a quadratic function of the input size, just like the worst-case running time.</p><p>In some particular cases, we shall be interested in the average-case running time of an algorithm; you could look for the technique of probabilistic analysis applied to various algorithms. The scope of average-case analysis is limited, because it may not be apparent what constitutes an &quot;average&quot; input for a particular problem. Often, we shall assume that all inputs of a given size are equally likely. In practice, this assumption may be violated, but we can sometimes use a randomized algorithm, which makes random choices, to allow a probabilistic analysis and yield an expected running time.</p><p>We used some simplifying abstractions to ease our analysis of the <code>insertionSort</code> procedure. First, we ignored the actual cost of each statement, using the constants <code>c<sub>i</sub></code> to represent these costs. Then, we observed that even these constants give us more detail than we really need: we expressed the worst-case running time as <code>an<sup>2</sup> + bn + c</code> for some constants <code>a</code>, <code>b</code>, and <code>c</code> that depend on the statement costs <code>c<sub>i</sub></code>. We thus ignored not only the actual statement costs, but also the abstract costs <code>c<sub>i</sub></code>.</p><p>We shall now make one more simplifying abstraction: it is the rate of growth, or order of growth, of the running time that really interests us. We therefore consider only the leading term of a formula (e.g., <code>an<sup>2</sup></code>), since the lower-order terms are relatively insignificant for large values of <code>n</code>. We also ignore the leading term&#x27;s constant coefficient, since constant factors are less significant than the rate of growth in determining computational efficiency for large inputs. For insertion sort, when we ignore the lower-order terms and the leading term&#x27;s constant coefficient, we are left with the factor of <code>n<sup>2</sup></code> from the leading term. We write that insertion sort has a worst-case running time of <code>θ(n<sup>2</sup>)</code>.</p><p>We usually consider one algorithm to be more efficient than another if its worst case running time has a lower order of growth. Due to constant factors and lower order terms, an algorithm whose running time has a higher order of growth might take less time for small inputs than an algorithm whose running time has a lower order of growth. But for large enough inputs, a <code>θ(n<sup>2</sup>)</code> algorithm, for example, will run more quickly in the worst case than a <code>θ(n<sup>3</sup>)</code> algorithm.</p><p>We found that the worst-case running time of insertion sort is <code>T(n) = θ(n<sup>2</sup>)</code>. Let us formalize what this notation means.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-asymptotic-notation">2.1 Asymptotic Notation<a class="hash-link" href="#21-asymptotic-notation" title="Direct link to heading">​</a></h2><p>Consider what theta is. We found our worst case <code>𝜃(n<sup>2</sup>)</code>. For a given function <code>g(n)</code> - that is, for our algorithm. We denote <code>𝜃(g(n))</code> as the set of the following functions when there is a set of positive constants <code>C</code> and <code>n<sub>0</sub></code> such that the inequality holds for every n greater than zero. Theta is an accurate estimate (it must be bounded at both the top and bottom). For example, an algorithm requiring <code>Ω(nlogn)</code> requires at least <code>nlogn</code> time, but the upper bound is not known. An algorithm requiring <code>Θ(nlogn)</code> is preferable because it requires at least <code>nlogn(Ω(nlogn))</code> and at most <code>nlogn(O(nlogn))</code>.</p><p>For a given function <code>g(n)</code> we denote by <code>θ(g(n))</code> the set of functions:</p><p><code>θ(g(n)) = { f(n)</code>: there exist positive constants <code>c<sub>1</sub></code>, <code>c<sub>2</sub></code> and <code>n<sub>0</sub></code> such that <code>0 ≤ c<sub>1</sub>g(n) ≤ f(n) ≤ c<sub>2</sub>g(n)</code> for all <code>n ≥ n<sub>0</sub> }</code></p><p>Figure 2.2</p><p><img loading="lazy" alt="img.png" src="/assets/images/asymptotic_notation_1-3b4c8894e7980c74e581cc8df82768bb.png" width="429" height="389" class="img_ev3q"></p><p>Theta notation is asymptotically tied to top and bottom functions, that is, it keeps it in a narrower framework. If we only have an upper bound, we use big O notation. For the functions <code>g(n)</code>, a positive constant must be satisfied and the inequality holds for each <code>n</code> greater than <code>0</code>. O large is most useful because it represents the worst case.</p><p>For a given function <code>g(n)</code> we denote by <code>θ(g(n))</code> the set of functions:</p><p><code>Ω(g(n)) = { f(n)</code>: there exist positive constants <code>c</code>, and <code>n<sub>0</sub></code> such that <code>0 ≤ cg(n) ≤ f(n)</code> for all <code>n ≥ n<sub>0</sub> }</code></p><p>Figure 2.3</p><p><img loading="lazy" alt="img.png" src="/assets/images/asymptotic_notation_2-848226436cfa86ee0ee05b2000721920.png" width="393" height="354" class="img_ev3q"></p><p>Omega notation. If big O is notation for the upper bound, then omega is for the lower one. It is defined in a similar way to big O, but we restrict the function from below. That is, we show the best implementation, for example, an already sorted collection in the input.</p><p>Figure 2.4</p><p><img loading="lazy" alt="img.png" src="/assets/images/asymptotic_notation_3-996fcc7c10d38c467fe0b30890c6f531.png" width="458" height="416" class="img_ev3q"></p><p>After that, you can already analyze your code, put down the execution time, etc. We&#x27;ve covered <code>insertionSort</code> using an incremental approach, i.e. each time we took the next element and considered for each sorted array. We remember that the quadratic option is not the best and let&#x27;s see what else we can use.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/algorithms-and-data-structures-part-2/algorithms"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">1. Algorithms</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/algorithms-and-data-structures-part-2/divide_and_conquer"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">3. Divide and Conquer</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#21-asymptotic-notation" class="table-of-contents__link toc-highlight">2.1 Asymptotic Notation</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/contents">Start learning</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/Introduction/help">Help</a></li></ul></div><div class="col footer__col"><div class="footer__title">Sources</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://git.epam.com/viktor_soroka/software-designs-and-algorithms" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitlab<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Software Designs and Algorithms, Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.35869dc7.js"></script>
<script src="/assets/js/main.0213352a.js"></script>
</body>
</html>